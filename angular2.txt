angular2

1) 移除了controll+$scope设计，改用组件式开发
2) 性能更好，渲染更快，变化检测效率更高
3) 优先为移动应用设计angular mobile toolkit
4) 更贴合标准化es6/7
5) angular 2 的使用不向下兼容angular 1, 需要使用upgrade adapter. 可以包装angular1的指令
6） Angular2 core concepts: Components, metadata, templates, data binding, services, directives, dependency injection, modules
7) components: core of angular 2, others provide supports for components.
8) component tree: app-> header, contactList, footer -> contactLists -> contact...
9) key elements of components: js logic + html template + css style, each components indepenetly provide its functionalities
10) communication between components: input and ouput attributes of components
11) full-lifecycle hook on components: constructor -> onChanges -> onInit -> OnChanges -> onDestroy
12) @Component: annotation (metadata) + class
13) attribute binding: <input [value]="myData" />
14) event binding: <input (keyup)="handle($event)" />
15) two-way binding: <input [(ngModel)]="myData" />
16) Parent component communicate to subcomponent by using attribute binding: In son: @Input data: IContact; In parent <contact [data]="item"></contact> 
7) subcomponent communicate to parent component by using event binding: @Output
17) component inhereits directives, but has its own template.
18) attribute directives: change template look and behavior, e.g. style
19) structure directive: change DOM structure of component template, e.g. ngif
20) service: component use DI to obtain service: providers: [LoggerService]
21) hierarchical dependency injection: service injected from parent can be obtained in sub components
22) source code modules: module feature provided by typescript, 
- @angular/core, @angular/common, @angular/forms, @angular/http
- import {Http} from "@angular/http"
23) app function modules: 
- @NgModule
- bootstrap module (root module, 一般叫AppModule)
- feature module1 + feature module2 + ...
- support lazy loading
- shared modules: module shared by feature1 and feature2...
- core module: security, header, footer... (only imported into bootstrap)
24) development environment: node + webpack + VsCode (free IDE from Microsoft)
25) webpack: entry + loaders + webpack.config.js (entry, output, loaders)

26) source structures
- package.json (npm dependencies, webpack module, angular modules...)
- tsconfig.json (typescript compiler configuration, required by typescript compiling)
- webpack.config.js (webpack building configuration)


#Angular CLI 
1) 开发： 项目开发 + 组件开发
2）Packaging:
3) Test:
4) 开发结构 vs. 运行结构
5）angular2开发效率和效果更高
6）angular CLI use Amber CLI + webpack

#Heroes tutotrial
7) npm install -g @angular/cli //install angular cli
8) ng new my-app //Generate a new project and skeleton application
9) cd my-app; ng serve --open //launches the server, watches your files, and rebuilds the app as you make changes to those files.
10) Using the --open (or just -o) option will automatically open your browser on http://localhost:4200/.
11) Your app lives in the src folder. All Angular components, templates, styles, images, and anything else your app needs go here. Any files outside of this folder are meant to support building your app.
12) Components are the fundamental building blocks of Angular applications. They display data on the screen, listen for user input, and take action based on that input.
13) The double curly braces are Angular's interpolation binding syntax. This interpolation binding presents the component's title property value inside the HTML header tag.
14)  create a new component to display hero information and place that component in the application shell.
ng generate component heroes
15) You always import the Component symbol from the Angular core library and annotate the component class with @Component.
@Component is a decorator function that specifies the Angular metadata for the component.
16) The CSS element selector, 'app-heroes', matches the name of the HTML element that identifies this component within a parent component's template.
17) The ngOnInit is a lifecycle hook Angular calls ngOnInit shortly after creating a component. It's a good place to put initialization logic.
18) Always export the component class so you can import it elsewhere ... like in the AppModule.
19) Format with the UppercasePipe: <h2>{{ hero.name | uppercase }} Details </h2>
- The word uppercase in the interpolation binding, right after the pipe operator ( | ), activates the built-in UppercasePipe.
20) Pipes are a good way to format strings, currency amounts, dates and other display data. Angular ships with several built-in pipes and you can create your own.
21) Every component must be declared in exactly one NgModule.
@NgModule({
  declarations: [
    AppComponent,
    HeroesComponent
  ],
  imports: [
    BrowserModule
    FormsModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})

22) The *ngFor is Angular's repeater directive. It repeats the host element for each element in a list.
<li *ngFor="let hero of heroes">

23) You could add more styles to styles.css and keep growing that stylesheet as you add components.

24) You may prefer instead to define private styles for a specific component and keep everything a component needs— the code, the HTML, and the CSS —together in one place.

25) You define private styles either inline in the @Component.styles array or as stylesheet file(s) identified in the @Component.styleUrls array.

26) Styles and stylesheets identified in @Component metadata are scoped to that specific component. The heroes.component.css styles apply only to the HeroesComponent and don't affect the outer HTML or the HTML in any other component.

27) <li *ngFor="let hero of heroes" (click)="onSelect(hero)"> //event binding syntax.
- The parentheses around click tell Angular to listen for the <li> element's click event. When the user clicks in the <li>, Angular executes the onSelect(hero) expression.

onSelect() is a HeroesComponent method that you're about to write. Angular calls it with the hero object displayed in the clicked <li>, the same hero defined previously in the *ngFor expression.

28) Keeping all features in one component as the application grows will not be maintainable. You'll want to split up large components into smaller sub-components, each focused on a specific task or workflow.

29) The hero property must be an Input property, annotated with the @Input() decorator, because the external HeroesComponent will bind to it like this.
<app-hero-detail [hero]="selectedHero"></app-hero-detail>

30) <app-hero-detail [hero]="selectedHero"></app-hero-detail>
[hero]="selectedHero" is an Angular property binding.

31) It's a one way data binding: HeroComponent.selectedHero property (parent) -> hero property of the target element, which maps to the hero property of the HeroDetailComponent.

32) Why services? Components shouldn't fetch or save data directly and they certainly shouldn't knowingly present fake data. They should focus on presenting data and delegate data access to a service.

33) ng generate service hero
The command generates skeleton HeroService class in src/app/hero.service.ts

34) The @Injectable() decorator tells Angular that this service might itself have injected dependencies.

35) Reserve the constructor for simple initialization such as wiring constructor parameters to properties. The constructor shouldn't do anything. It certainly shouldn't call a function that makes HTTP requests to a remote server as a real data service would.

*36) ng generate module app-routing --flat --module=app
--flat puts the file in src/app instead of its own folder.
--module=app tells the CLI to register it in the imports array of the AppModule.

37) Routes tell the router which view to display when a user clicks a link or pastes a URL into the browser address bar.

38) A typical Angular Route has two properties: 
- path: a string that matches the URL in the browser address bar. 
- component: the component that the router should create when navigating to this route.

39) The RouterOutlet is one of the router directives that became available to the AppComponent because AppModule imports AppRoutingModule which exported RouterModule.

40) HttpClient is Angular's mechanism for communicating with a remote server over HTTP.

#Architecture Overview
1) Angular is a framework for building client applications in HTML and either JavaScript or a language like TypeScript that compiles to JavaScript.

2) The framework consists of several libraries, some of them core and some optional.

***3) You write Angular applications by composing HTML templates with Angularized markup, writing component classes to manage those templates, adding application logic in services, and boxing components and services in modules.

4) Then you launch the app by bootstrapping the root module. Angular takes over, presenting your application content in a browser and responding to user interactions according to the instructions you've provided.

5) Angular apps are modular and Angular has its own modularity system called NgModules. An NgModule, whether a root or feature, is a class with an @NgModule decorator.

6) Every Angular app has at least one NgModule class, the root module, conventionally named AppModule.

7) While the root module may be the only module in a small application, most apps have many more feature modules, each a cohesive block of code dedicated to an application domain, a workflow, or a closely related set of capabilities.

8) Angular ships as a collection of JavaScript modules. You can think of them as library modules. Each Angular library name begins with the @angular prefix.

9) You install them with the npm package manager and import parts of them with JavaScript import statements. import Angular's Component decorator from the @angular/core library like this:
import { Component } from '@angular/core';

10) A component controls a patch of screen called a view. For example, the following views are controlled by components:
The app root with the navigation links.
The list of heroes.
The hero editor.

11) Although this template uses typical HTML elements like <h2> and <p>, it also has some differences. Code like *ngFor, {{hero.name}}, (click), [hero], and <hero-detail> uses Angular's template syntax.

12) Metadata tells Angular how to process a class. the @Component decorator, which identifies the class immediately below it as a component class.
@Component({
  selector:    'app-hero-list',
  templateUrl: './hero-list.component.html',
  providers:  [ HeroService ]
})

13) @Component configuration options:
- providers: array of dependency injection providers for services that the component requires. This is one way to tell Angular that the component's constructor requires a HeroService so it can get the list of heroes to display.

14) As the diagram shows, there are four forms of data binding syntax. Each form has a direction — to the DOM, from the DOM, or in both directions.

15) The {{hero.name}} "interpolation" displays the component's hero.name property value within the <li> element.
<li>{{hero.name}}</li>

16) The [hero] property binding passes the value of selectedHero from the parent HeroListComponent to the hero property of the child HeroDetailComponent.
<app-hero-detail [hero]="selectedHero"></app-hero-detail>

17) The (click) event binding calls the component's selectHero method when the user clicks a hero's name.
<li (click)="selectHero(hero)"></li>

18) In two-way binding, a data property value flows to the input box from the component as with property binding. The user's changes also flow back to the component, resetting the property to the latest value, as with event binding.
<input [(ngModel)]="hero.name">

19) Data binding plays an important role in communication between a template and its component. Data binding is also important for communication between parent and child components.

20) Angular templates are dynamic. When Angular renders them, it transforms the DOM according to the instructions given by directives.
- A directive is a class with a @Directive decorator. A component is a directive-with-a-template; a @Component decorator is actually a @Directive decorator extended with template-oriented features.

21) A directive is a class with a @Directive decorator. A component is a directive-with-a-template; a @Component decorator is actually a @Directive decorator extended with template-oriented features.

22) Two other kinds of directives exist: structural and attribute directives. They tend to appear within an element tag as attributes do, sometimes by name but more often as the target of an assignment or a binding.

23) Structural directives alter layout by adding, removing, and replacing elements in DOM.
- <li *ngFor="let hero of heroes"></li>: *ngFor tells Angular to stamp out one <li> per hero in the heroes list.
- <app-hero-detail *ngIf="selectedHero"></app-hero-detail>: *ngIf includes the HeroDetail component only if a selected hero exists.

24) Attribute directives alter the appearance or behavior of an existing element. In templates they look like regular HTML attributes, hence the name.
- The ngModel directive, which implements two-way data binding, is an example of an attribute directive. ngModel modifies the behavior of an existing element (typically an <input>) by setting its display value property and responding to change events.
<input [(ngModel)]="hero.name">
- Angular has a few more directives that either alter the layout structure (for example, ngSwitch) or modify aspects of DOM elements and components (for example, ngStyle and ngClass).

25) Service is a broad category encompassing any value, function, or feature that your application needs.
Examples include:
logging service
data service
message bus
tax calculator
application configuration

26) There is nothing specifically Angular about services. Angular has no definition of a service. There is no service base class, and no place to register a service.

27) Component classes should be lean. They don't fetch data from the server, validate user input, or log directly to the console. They delegate such tasks to services. A component's job is to enable the user experience and nothing more. It mediates between the view (rendered by the template) and the application logic (which often includes some notion of a model). A good component presents properties and methods for data binding. It delegates everything nontrivial to services.

28) Angular can tell which services a component needs by looking at the types of its constructor parameters. For example, the constructor of your HeroListComponent needs a HeroService:
constructor(private service: HeroService) { }

29) When Angular creates a component, it first asks an injector for the services that the component requires.
- An injector maintains a container of service instances that it has previously created. 
- If a requested service instance is not in the container, the injector makes one and adds it to the container before returning the service to Angular. 
- When all requested services have been resolved and returned, Angular can call the component's constructor with those services as arguments. This is dependency injection.

30) More precisely, the redisplay occurs after some kind of asynchronous event related to the view, such as a keystroke, a timer completion, or a response to an HTTP request.

31) When you bootstrap with the AppComponent class (in main.ts), Angular looks for a <app-root> in the index.html, finds it, instantiates an instance of AppComponent, and renders it inside the <app-root> tag. 
src/index.html
<body>
  <app-root></app-root>
</body>

32) The *ngFor in the <li> element is the Angular "repeater" directive. It marks that <li> element (and its children) as the "repeater template":
<li *ngFor="let hero of heroes">
  {{ hero }}
</li>
- Don't forget the leading asterisk (*) in *ngFor. It is an essential part of the syntax. 
- In this case, ngFor is displaying an array, but ngFor can repeat items for any iterable object.

33) Creating a class for the data
ng generate class hero
export class Hero {
  constructor(
    public id: number,
    public name: string) { }
}

34) It might not look like the class has properties, but it does. The declaration of the constructor parameters takes advantage of a TypeScript shortcut.

35) The Angular ngIf directive inserts or removes an element based on a truthy/falsy condition.
<p *ngIf="heroes.length > 3">There are many heroes!</p>

36) The template expression inside the double quotes, *ngIf="heroes.length > 3", looks and behaves much like TypeScript. When the component's list of heroes has more than three items, Angular adds the paragraph to the DOM and the message appears. If there are three or fewer items, Angular omits the paragraph, so no message appears.

37) You use interpolation to weave calculated strings into the text between HTML element tags and within attribute assignments.

38) Directive and component instances have a lifecycle as Angular creates, updates, and destroys them. Developers can tap into key moments in that lifecycle by implementing one or more of the lifecycle hook interfaces in the Angular core library.

39) Interfaces are optional (technically); Angular instead inspects directive and component classes and calls the hook methods if they are defined. Angular finds and calls methods like ngOnInit(), with or without the interfaces.
- Nonetheless, it's good practice to add interfaces to TypeScript directive classes in order to benefit from strong typing and editor tooling.

40) They are not inherited by any components nested within the template nor by any content projected into the component.

41) Class names and selectors are local to the component and don't collide with classes and selectors used elsewhere in the application.

42) With HttpClient, @angular/common/http provides a simplified API for HTTP functionality for use with Angular applications, building on top of the XMLHttpRequest interface exposed by browsers. Additional benefits of HttpClient include testability support, strong typing of request and response objects, request and response interceptor support, and better error handling via apis based on Observables.

43) Introducing Angular pipes, a way to write display-value transformations that you can declare in your HTML.

#Internationalization (i18n)
1) Application internationalization is a many-faceted area of development, focused on making applications available and user-friendly to a worldwide audience. 

2) Angular simplifies the following aspects of internationalization:
Displaying dates, number, percentages, and currencies in a local format.
Translating text in component templates.
Handling plural forms of words.
Handling alternative text.

3) A locale is an identifier (id) that refers to a set of user preferences that tend to be shared within a region of the world, such as country. This document refers to a locale identifier as a "locale" or "locale id".

4) A Unicode locale identifier is composed of a Unicode language identifier and (optionally) the character - followed by a locale extension. (For historical reasons the character _ is supported as an alternative to -.) For example, in the locale id fr-CA the fr refers to the French language identifier, and the CA refers to the locale extension Canada.

5) By default, Angular uses the locale en-US, which is English as spoken in the United States of America

6) To set your app's locale to another value, use the CLI parameter --locale with the value of the locale id that you want to use:
ng serve --aot --locale fr

7) If you use JIT, you also need to define the LOCALE_ID provider in your main module:
import { LOCALE_ID, NgModule } from '@angular/core';
providers: [ { provide: LOCALE_ID, useValue: 'fr' } ],

8) Angular pipes can help you with internationalization: the DatePipe, CurrencyPipe, DecimalPipe and PercentPipe use locale data to format data based on the LOCALE_ID.

9) By default, Angular only contains locale data for en-US. If you set the value of LOCALE_ID to another locale, you must import locale data for that new locale. 

#imooc angular
1) component: 可以理解为一段带有业务逻辑和数据的html
2）service: 封装可重用的业务逻辑
3）module: 将应用中不同部分组织成一个Angular框架可以理解的单元 （用来打包元素的）
4）directive: 允许你向html元素添加自定义行为

#Environment setup
1) install node
2) install angular-cli: npm install -g @angular/cli; ng -v 
3) create project structure: ng new auction
- do not change the structure and file names
4) Component
@Component decorator + template, selector, style, provider
5) component class:
@Input
@Output
lifecycle hooks
Aminiations
6) module
- @NgModule
declarations：要用的元素，只能声明组件，指令和管道。 AppComponent....
imports：要用的模块： BrowserModule(必选）, FormsModule, HttpModule， after importing the modules, you can access the elemnents in those modules.
providers: 要用的服务， 只能声明服务
bootstrap: 声明主组件是什么
7） angular启动过程？
- 启动时加载了那个页面？
index.html

- 启动时加载了哪些脚本？
main.ts 
package js (from main.ts -> all imports， including platformBrowserDynamic， AppModule, AppModule imports AppComponent)

- 这些脚本做了什么事情？
look for AppCompment's "selector(app-root)" in index.html, replace the selector 

8) debug frontend in IDE
in chrome://extensions, install jetbrains ide support
settings->debuger->built-in server

9）install admin-lte template
npm install --save admin-lte 

10）copy and paste admin-lte starter page source

11) install bootstrap
npm install --save bootstrap

12) 在.angular-cli中引入CSS，
 	"styles": [
        "styles.css",
        "../node_modules/bootstrap/dist/css/bootstrap.min.css",
        "../node_modules/admin-lte/dist/css/AdminLTE.min.css",
        "../node_modules/admin-lte/dist/css/skins/skin-blue.min.css"
      ],

13) ng g component header; 
ng g component menu; 
ng g component sidebar; 
ng g component footer; 
ng g component content
ng g component stock/stockManage


14) 路由

15) SPA 不进行页面跳转，不重新加载整个页面，一直停留在index.html

16) SPA 可以理解成一组视图状态的集合

17) route key components
- Routes: 路由配置，保存着哪个URL对应展示那个组件，以及在哪个RouterOutlet中展示组件
- RouterOutlet: 在Html中标记路由内容呈现位置的占位符指令
- Router: 负责在运行时执行路由的对象，可以通过调用其navigate()和navigateByUrl()方法来导航到一个指定的路由
- RouterLink: 在Html中声明路由导航用的指令
- ActivatedRoute: 当前激活的路由对象，保存着当前路由的信息，如路由地址，路由参数等。

18) ng g app-routing --routing
- generate an additional module - AppRoutingModule(app-routing.module.ts)； in it, we can declare Routes object and apply the routes
- the AppRouting module is also imported into the root module
- In routing module:
const routes: Routes = [
  {path: '', component: HomeComponent},
  {path: 'stock', component: StockComponent},
  {path: '**', component: Code404Component}
];

- In html:
<a [routerLink]="['/']">主页</a>
<a [routerLink]="['stock']">股票详情</a>
<input type="button" value="股票详情" (click)="toStockDetail()">
<router-outlet></router-outlet>

- In component(parent component displaying the routed components):
  constructor(private router: Router) {
  }
  toStockDetail() {
    this.router.navigate(['/stock']);
  }


ng g component home
ng g component stock

19) 通过路由的查询参数递数据：{path:/product?id=1&name=2 => ActivatedRoute.queryParams[id]
- In html:
<a [routerLink]="['stock']" [queryParams]="{id:1}">股票详情</a>
- In child component(stock component) ts:
constructor(private routeInfo: ActivatedRoute) {
    this.stockId = routeInfo.snapshot.queryParams["id"]
  }
- In child component(stock component) html: 
股票id: {{stockId}}

20) 通过路由的路径传递参数： {path:/proudct/:id} =>/product/1 => ActivatedRoute.params[id]
- In route module ts:
const routes: Routes = [
  {path: '', component: HomeComponent},
  {path: 'stock/:id', component: StockComponent},
  {path: '**', component: Code404Component}
];

- In parent html:
<a [routerLink]="['stock', 1']" ">股票详情</a>

- In parent ts:
toStockDetail() {
    this.router.navigate(['/stock', 2]);
  }

- In child component(stock component) html: 
股票id: {{stockId}}

- In child component(stock component) ts:
constructor(private routeInfo: ActivatedRoute) {
    this.stockId = routeInfo.snapshot.params["id"]
  }

21) 参数快照 vs 参数订阅
ngOnInit() {
    //this.stockId = routeInfo.snapshot.params["id"]; //only invoke when component is created.
    this.routeInfo.params.subscribe((params: Params) => this.stockId = params["id"]); //execute everytime the route params changed. 
  }

22) 路由配置中传递参数： {path:/product, component: ProductComponent, data: [{isProd: true}]} => ActivatedRoute.data[0][isProd]
- In child/stock component:
private isProd: boolean;
this.isProd = this.routeInfo.snapshot.data[0]["isProd"];

- In route component: 
{path: 'stock/:id', component: StockComponent, data: [{isProd: true}]},

23) redirection
{path: '', redirectTo: '/home', pathMatch: 'full'},
{path: 'home', component: HomeComponent},

23) nested routing
- in route ts:
 {path: 'stock/:id', component: StockComponent, data: [{isProd: true}], children :
    [
      {path: '', component: BuyerListComponent},
      {path: 'seller/:id', component: SellerListComponent}
    ]
  },

- In stock html:
<a [routerLink]="['./']">买家列表</a>
<a [routerLink]="['./seller',100]">卖家列表</a>
<router-outlet></router-outlet>

- In seller ts:
	constructor(private routeInfo: ActivatedRoute) { }

  ngOnInit() {
    this.sellerId = this.routeInfo.snapshot.params['id'];
  }

24) 辅助路由: 可以控制一组路由的变化
- In route moudle ts:
{path: 'consult', component: ConsultComponent, outlet: 'aux'},

- In app component: 
<a [routerLink]="[{outlets: {primary： ‘home',aux: 'consult'}}]">开始咨询</a>  //同时变化primary和aux的路由组件
<a [routerLink]="[{outlets: {aux: null}}]">结束咨询</a>

<router-outlet></router-outlet>
<router-outlet name="aux"></router-outlet>

25) 路由守卫： CanActivate: 处理导航到某路由的情况

26） CanDeactivate: 处理从当前路由离开的情况

27）Resolve： 在路由激活之前获取路由数据

28） Dependency Injection:
- In module
@NgModule({
	providers: [ProductService] 
	//prodviders: [{provide:ProductService, useClass: ProductService}]
	//providers: [AnotherProductService] 
	//providers: [MockProductService] 
})

- In component which will use the service:
constructor(productService: productService) {
	this.product = productService.getProudct();
}

29) Injector: 
constructor(productService: ProductService) {} //angular injector search for ProductService and inject into component constructor

30) provider:
providers: [ProductService]
prodviders: [{provide:ProductService, useClass: ProductService}]
//provide ProductService to injector
prodviders: [{provide:ProductService, useClass: AnotherProductService}]
prodviders: [{provide:ProductService, useFactory: () => {...}}]

31）provider scope:
- what are the differences bewteen declared services in component or in module?
- 1) service declared in module providers, can be used by all components in the module （components in declarations)
- 2) service declared in @component providers, can be used by only by the component and its subcomponent.
- 3) when same token is used by both module and component, the token decared in component overrides the token in module.
- 4) service are preferrably delared in module, only declaration is necessary in component then declared in component.

32) @Injectable()
- annotated class can injecte OTHER services into constructor  
- suggested add @Injectable to all service class
- @Component is subclass of @Injectable

33）使用工厂(factory)和值声明提供器
 providers: [
    {
      provide: StockService, useFactory: (logger:LoggerService, isDev) => {
      console.log(isDev);
      if (isDev) {
        return new StockService(logger);
      } else {
        return new AnotherStockService(logger);
      }
    }, deps: [LoggerService, "IS_DEV_ENV"]
    }
    , LoggerService,
    {provide: "IS_DEV_ENV", useValue: {isDev: false}}],

34) 注入器的层级关系
（1） 应用级注入器
- 当angular应用启动时，angular创建应用级注入器，将angular app module中声明的所有providers注册到应用级注入器
- 同时将所有import的模块中声明的providers也注册到应用级注入器
(2) 组件级注入器
- angular会启动主组件， 同时应用级注入器会为主组件创建主组件注入器， 并将组件中声明的providers注入到主组件中
（3） 子组件注入器
- 父组件的注入器为子组件创建注入器，并将子组件声明的providers注入到子组件中
（4）当组件注入service时，会从组件，父组件，应用逐级寻找provider
（5）不同于Java/Spring component有许多注入点，angular component只能从constructor注入

35）数据绑定
<h1>{{productTitle}}!</h1> //insert value of productTitle
<img [src] = "imgUrl"> //HMTL tag binding to expression imgUrl
<button (click)="toProductDetail()">商品详情</button> //event handling binding to method toProductDetail()

36) event binding
- <button (click)="onButtonClick($event)"> //$event = 浏览器事件对象，target对象指向产生事件的节点
- <button (click)="saved = true"> //可以是函数调用，也可以是属性赋值。 组件TS的saved attribute设置为true
- 事件可以是标准的DOM事件，也可以是自定义事件， 自定义事件，并发射出来。

37) 属性绑定 = 插值表达式
<img [src]="imgUrl"><br>
<img src="{{imgUrl}}">

38) html属性 vs. DOM属性
<input value="Tom" (input)="doOnInput($event)">
- 当浏览器渲染以上字符串时，会创建一个dom节点，即一个类型为html input element的对象，每一个DOM元素都有自己的属性和方法
- 以此input为例，DOM input元素的value属性会被初始化为Tom

doOnInput(event: any) {
    console.log(event.target.value) //打印input的value属性(DOM属性） ：变化
    console.log(event.target.getAttribute("value")); //打印html属性： 不变
  }

39) <button disabled>点我</button>
- html attribute disabled出现即禁用，不管设置为true或者false
- 然后可以通过dom属性disabled来设置是否禁用

40) html属性和DOM属性的关系
- 少量html属性和DOM属性之间有着1：1的映射，如Id.
- 有些html属性没有对应的DOM属性， 如colspan
- 有些dom属性没有对应的html属性。 如textContent
- 就是名字相同，html属性和DOM属性也不是同一样东西
- html属性的值指定了初始值；DOM属性的值表示当前值。 
- DOM属性的值可以改变，html属性的值不能改变
- 模板绑定是通过DOM属性和事件来工作的，而不是html属性

41） angular bind attriute value (name: string = 'IBM') to DOM element (inputELement.value === 'IBM'); browser render the DOM, so that IBM is deplayed on browser

42) html binding: 
- basic html attribute binding: 
<td [attr.colspan]="size">Something</td>

- CSS class binding: 
<div class="aaa bbb" [class]="someExpression">something</div> //someExpression replace 'aaa bbb'
<div [class.special]="isSpecial">something</div> //if isSpecial=true, apply class special 
<div [ngClass]="{aaa:isA, bbb:isB}}"> //isA. isB true then aaa and bbb

- style binding
<button [style.color]="isSpecial"?'red':'green'">Red</button> //color = expression value"
<div [ngStyle]="{'font-style':this.canSave?'italic':'normal'}"> //multiple styles

43) 双向绑定
- <input [(ngModel)]="dname">
{{dname}}
- input, textArea
- 绑定在显示类的标签上是没用的。 <div>, <span>...

44) reactive programming
	Observable.from([1,2,3,4,5,6])
      .filter(e => e % 2 == 0)
      .map(e => e*e)
      .subscribe(
        e => console.log(e),
        err => console.log(err),
        () => console.log("end")
      );
- Observable (stream): a collection of values or events
- Observer: 3 callback functions: 
- Subscription: use to cancel subscription. subscribtion.unscribe()
- Operator: functions such as filter, map

45) 模板本地变量 (Template local variable)
- <input (keyup)="onKey($event)">
- <input #myField (keyup)="onKey(myField.value)"> //myField is a ref to the input element 

onKey1(value: string) {
    console.log(value);
  }

46) Treat event as stream
- import ReactiveFormModule
- FormControl represents form element
searchInput: FormControl = new FormControl();
- <input [formControl]="searchInput">
this.searchInput.valueChanges
.debounceTime(500)
.subscribe(stockCode => getStockInfo(stockCode));

#Pipe
47) lowercase; uppercase; date; number; async
<p>我的生日是{{birthday | date | uppercase}}</p><br>
我的生日是FEB 18, 2018
<p>我的生日是{{birthday | date : 'yyyy-MM-dd HH:mm:ss'}}</p><br>
我的生日是2018-02-18 21:15:14

<p>圆周率是{{pi | number: '2.2-2'}}</p> //2 is 整数位， 2-2最少小数位，最大的小数位
圆周率是03.14

<p>圆周率是{{pi | async }}
在页面处理异步流

48) custom pipe
- ng g pipe pipe/multiple

<tr *ngFor="let stock of stocks | stockFilter: 'name': keyword; let i = index;">

export class StockFilterPipe implements PipeTransform {
  transform(list: any, field:string, keyword:string): any {
    if (!field || !keyword) {
      return list;
    }
    return list.filter(item => {
      let itemFieldValue = item[field].toLowerCase();
      return itemFieldValue.indexOf(keyword) >= 0;
    })
  }

  49）Parent -> child @Input: 输入属性
父组件html
  <div>我是父组件</div>
<div>
  <input placeholder="请输入搜索关键字" [(ngModel)]="search">
  <app-stock-search [keyword]="search"></app-stock-search>
</div>

子组件ts
 @Input()
  private keyword:string;
}

50) EventEmitter: a subclass of Subject, can be either event Observer or Observable, therefore, EventEmitter can both emit custom event and subscribe to event stream.

51) child -> parent @Output
子组件ts：
 @Output('lastPrice')
 private searchResult: EventEmitter<StockInfo> = new EventEmitter();

 this.searchResult.emit(stockInfo);

父组件html：
<app-stock-search [keyword]="search" (lastPrice)="getStockInfo($event)"></app-stock-search>
父组件ts：
getStockInfo(stockInfo: StockInfo) {
    this.currentPrice = stockInfo.price;
}

52) 中间人模式: child1 -> child2
child1 -> parent @Output; trigger emit
parent -> child2 @Input 


53) Lifecycle hook
组件初始化, 组件变化*，组件销毁+
- constructor
- ngOnChanges*
- ngOnInit
- ngDoCheck*
- ngAfterContentInit
- ngAfterContentChecked*
- ngAfteViewInit
- ngAfterViewChecked*
- ngDestroy+

54) ngOnChanges在parent initialize/change child component attributes时调用, first invocation happens before ngOnInit
- @Input() attributes are not initlized when constructor is called, therefore, if the initilization logic needs input from parent, 
then the logic need to be done in ngOnInit
- 可变对象 vs. 不可变对象： string不可变，object是可变的
- ngOnChanges方法只有在输入属性，不可变对象属性变化时才会调用；内部属性，可变对象属性的属性值变化时不会调用。 

55）ngOnInit 组件初始化
56) ngDoCheck 变更检测，在angular每个变更周期内调用
- zone.js来实现
- 浏览器的任何事件（包括原生事件）都会引起变更检测，整个组件树都会被检测， 因此DoCheck被频繁调用，因此需要进行检测看是否是由关注的属性变化引起的
- 每个组件都有一个变更检测器
- default，OnPush策略

57）如何从父组件调用子组件的方法
parent html:
	<app-view-child #child1></app-view-child>
  	<app-view-child #child2></app-view-child>
  	<button (click)="child2.greeting('Jerry')">点击</button>

parent ts:
	@ViewChild("child1")
  child1: ViewChildComponent;

  ngOnInit():void {
    this.child1.greeting("Tom");
  }

child ts：
greeting(name:string) {
    console.log("hello " + name);
  }

58）View钩子
- ngAfterViewInit, ngAfterViewCheck 与组件模板检查相关

59) 中间人模式，第六章又讲，基本思路是用Service当中间人，在无关系的两个组件里都注入同一个Service，一个组件里用Service的EventEmitter类型的属性发射事件，另一个组件里去监听。

57） ngAfterContentInit, ngAfterContentCheck 与组件内容投影相关

58) 模板式表单 (使用指令定义数据模型)
NgForm: 代表整个表单， 被自动添加到每一个表单上，会隐式创建一个FormGroup object。 代表表单实例， 并存储表单数据
NgModel: 代表表单字段， 不需要[()], 不需要在ts中声明对象. 创建FormControl object. 
NgModelGrou：

59) angular自动接管form表单，加ngForm指令，可以用ngNoForm指令取消接管. div + ngForm = form
<div>
  {{myForm.value | json}}
</div>

60) <div>Username: <input #myNickName="ngModel" ngModel name="nickname" type="text"></div>
<div>
  {{myNickname.value}}
</div>

61) NgModelGroup： 代表表单的一组输入字段, 形成层次
<div ngModelGroup="passwordInfo">
    <div>Password: <input type="password"></div>
    <div>Confirm password: <input type="password"></div>
 </div>

62) 模板式表单样例
 <form #myForm="ngForm" (ngSubmit)="createUser(myForm.value)">
  <div>Username: <input ngModel name="nickname" type="text" required pattern="[a-zA-Z0-9]+"></div>
  <div>Email: <input ngModel name="email" type="text"></div>
  <div>Mobile: <input ngModel name="mobile" type="number"></div>
  <div ngModelGroup="passwordInfo">
    <div>Password: <input ngModel name="password" type="password"></div>
    <div>Confirm password: <input ngModel name="passwordConfirm" type="password"></div>
  </div>
  <button type="submit">Register</button>
</form>

<div>
  {{myForm.value | json}}
</div>

63) 响应式表单
- 编码创建数据模型
- 用指令连接模板和数据模型

64) 响应式表单 - 数据模型类
- FormControl: 输入元素的信息, 值，校验信息等等
- FormGroup: FormControl的集合
- FormArray: an array of FormControl

65) 响应式表单ts - 在constructor里面建立数据模型：
constructor() {
    this.formModel = new FormGroup({
      nickname: new FormControl(),
      emails: new FormArray([
        new FormControl()
      ]),
      mobile: new FormControl(),
      passwordInfo: new FormGroup({
        password: new FormControl(),
        passwordConfirm: new FormControl()
      })
    })

66）指令与模板式表单完全不同：
- formGroup, formGroupName
- formControl, formControlName
- formArrayName
- 模板式表单都是以ng开头，如ngModel, ngForm, ngSubmit

67) 响应式表单html: formGroup, formControlName 指令
<form [formGroup]="formModel" (submit)="createUser()">
  <div>Username: <input formControlName="nickname" type="text" required pattern="[a-zA-Z0-9]+"></div>
  <div>Emails:
    <ul formArrayName = "emails">
      <li *ngFor = "let email of formModel.get('emails').controls; let i = index">
        <input [formControlName]="i">
      </li>
    </ul>
    <button type="button" (click)="addEmail()">Add email</button>
  </div>
  <div>Mobile: <input formControlName="mobile" type="number"></div>
  <div formGroupName="passwordInfo">
    <div>Password: <input formControlName="password" type="password"></div>
    <div>Confirm password: <input formControlName="passwordConfirm" type="password"></div>
  </div>
  <button type="submit">Register</button>
</form>

(68) Use FormBuilder to reduce code volumn, 还可以传入更多的参数，例如默认值，校验器
private fb:FormBuilder = new FormBuilder();

  constructor() {
    this.formModel = this.fb.group({
      nickname: [''],
      emails: this.fb.array([
        ['']
      ]),
      mobile: [''],
      passwordInfo: this.fb.group({
        password: [''],
        passwordConfirm: ['']
      })
    })
  }

（69）angular的校验器
- custom validator: a method
aValidationMethod(param: AbstractControl): {[key:string]: any} {
	return null;
}
- AbstractControl is parent of FormControl, FormGroup, FormArray

- predefine validator (Validators.required, maxLength, pattern)

(70) 内置校验器
 nickname: ['default', [Validators.required, Validators.minLength(6)]],

 let nickNameValid:boolean = this.formModel.get("nickname").valid;
    console.log("nickname is valid? " + nickNameValid );
    let nickNameErrors:any = this.formModel.get("nickname").errors;
    console.log("nickname's errors? " + JSON.stringify(nickNameErrors));

(71) 自定义校验器
 mobileValidator(mobile: FormControl):any {
    let value = (mobile.value || '') + '';
    var myreg =/^(((13[0-9]{1})|(15[0-9]{1})|(18[0-9]{1}))+\d{8})$/;
    let valid = myreg.test(value);
    console.log("mobile format is valid? " + valid);
    return valid? null: {mobile: true};
  }

(72) 自定义校验器For FormGroup
passwordValidator(info: FormGroup): any {
    let password: FormControl = info.get('password') as FormControl;
    let pConfirm: FormControl = info.get('passwordConfirm') as FormControl;
    let valid: boolean = password.value === pConfirm.value;
    console.log('password matched: ' + valid);
    return valid ? null: {password:true};
  }

(73) refactor validator into seperate class for reuse: create a file and export global function
export function mobileValidator(mobile: FormControl):any {
  let value = (mobile.value || '') + '';
  var myreg =/^(((13[0-9]{1})|(15[0-9]{1})|(18[0-9]{1}))+\d{8})$/;
  let valid = myreg.test(value);
  console.log("mobile format is valid? " + valid);
  return valid? null: {mobile: true};
}

(74) 在模板上展示错误信息
<div>Username: <input formControlName="nickname" type="text" required pattern="[a-zA-Z0-9]+"></div>
  <div [hidden]="!formModel.hasError('required','nickname')">
    Nickname must be provided
  </div>
  <div [hidden]="!formModel.hasError('minlength','nickname')">
    Nickname's minimum length is 6
  </div>

<div [hidden]="!formModel.hasError('mobile','mobile')">
    Mobile name is incorrect.
  </div>

(75) 输入信息来自Validator而非html
<div [hidden]="!formModel.hasError('password','passwordInfo')">
    {{formModel.getError('password','passwordInfo')?.description}}
  </div>

  return valid ? null: {password: {description: 'password not matched'}};

（76）异步校验器
mobile: ['', mobileValidator, mobileAsyncValidator],
export function mobileAsyncValidator(mobile: FormControl):any {
  let value = (mobile.value || '') + '';
  var myreg =/^(((13[0-9]{1})|(15[0-9]{1})|(18[0-9]{1}))+\d{8})$/;
  let valid = myreg.test(value);
  console.log("mobile format is valid? " + valid);
  return Observable.of(valid? null: {mobile: true}).delay(5000);
}

77) 问号的意思是问号之前的表达式如果有值，就执行问号后面的部分，如果问号之前的部分是undefine，就不执行后面的部分。
{{formModel.getError('password','passwordInfo')?.description}}

78) 状态字段： touched and untouched
- 表示用户是否访问过该字段， 即字段是否获取过焦点
- 常用于当用户为访问过某字段时， 不显示错误信息

<div [hidden]="formModel.get('passwordInfo.password').valid || formModel.get('passwordInfo.password').untouched">
    <div [hidden]="!formModel.hasError('required','passwordInfo.password')">
      password must be provided
    </div>
    </div>

79） pristine and dirty： 属性的值是否被改变过
- <div [hidden]="formModel.get('mobile').valid || formModel.get('mobile').pristine">

80） pending： 异步校验时pending为true
<div [hidden]="!formModel.get('mobile').pending">
    Mobile is checked remotely  </div>

81) 利用字段不同状态的为字段添加不同状态下的CSS 样式
.ng-invalid
<input [class.inputHasError]="formModel.get('nickname').invalid" formControlName="nickname" type="text">











***************************************************************************************************************************************
# Asim CodeCraft TV
1) To the outside world the input property name is still joke and we could keep the JokeListComponent template the same as before:
<joke *ngFor="let j of jokes" [joke]="j"></joke>

class JokeComponent {
  @Input('joke') data: Joke;
}

2) <joke-form (jokeCreated)="addJoke($event)"></joke-form>
- The components tag, its selector, is going to be joke-form.
- The component is going to emit an event called jokeCreated whenever a user clicks the Create button.
- We treat the component as a black-box, we don’t care how the component is implemented or how the user interacts with it. The parent component just wants to know when the user has created a new joke.

3) An EventEmitter is a helper class which we can use to emit events when something happens, other components can then bind and react to these events.
import {Output, EventEmitter} from '@angular/core';
.
.
.
class JokeFormComponent {
  @Output() jokeCreated = new EventEmitter<Joke>();
}
- When the jokeCreated event fires we are going to pass out an instance of a Joke.


4) Lets now create a function called createJoke() and have it actually output an event, like so:
Copyclass JokeFormComponent {
  @Output() jokeCreated = new EventEmitter<Joke>();

  createJoke() {
    this.jokeCreated.emit(new Joke("A setup", "A punchline"));
  }
}

5) We need to call the createJoke function when the user clicks the Create button, like so:
<button type="button"
      class="btn btn-primary"
      (click)="createJoke()">Create
</button>

6) We also need to bind to the output event property on our parent JokeListComponent so we can add the joke that gets output to the list of jokes, like so:

addJoke(joke) {
    this.jokes.unshift(joke);
  }

7) $event is a special variable and holds whatever was emitted by the jokeCreated EventEmitter, in our case its an instance of a Joke.

#Form
8) use something called a template reference variable. We add the string #setup to our setup input control, like so:
<input type="text"
       class="form-control"
       placeholder="Enter the setup"
       #setup>
- #setup now points to the DOM element that represents an <input> control, which is an instance of the type HTMLInputElement.

9) 
<button type="button"
      class="btn btn-primary"
      (click)="createJoke(setup.value, punchline.value)">Create
</button>

10) Finally we change the createJoke function so it accepts these new arguments and uses them to construct an instance of a Joke, like so:
createJoke(setup: string, punchline: string) {
  this.jokeCreated.emit(new Joke(setup, punchline));
}

11） Similar to input properties, we can also create output properties on our custom components using the "@Output annotation".

12） "These output properties are always instances of the EventEmitter" class and we output events by calling the emit function. Whatever we pass in to the emit function is output as the "$event" template variable.

13） We can create "local template variables" by adding variables starting with the # character on any element in our template.
By default that variable is only visible in the template that it’s declared in and points to the DOM element it’s attached to.

14）TypeScript is a super-set of ES6. That means whatever features we have in ES6 are also in TypeScript with some extra features on top, such as static typing and richer syntax.

15） ES6 is an agreement for how JavaScript should function in the future. Its up to each browser manufacturer to implement those features according to that agreement. Therefore all browsers don’t support all the features of ES6 yet. Chrome has the best support by far and so does Node. 

16）Sometimes ES6 features are only switched on when we are in "use strict" mode, so to test our ES6 code my recommendation is to always add "use strict" to the top of your files.

17) A confusing point for developers coming from different languages is the way variable scope behaves in JavaScript. in ES5 JavaScript we only have two scopes, the global scope and function scope.

18) The variable a, as we’ve declared it above, exists in global scope so this means it’s visible from everywhere in our application.
{
  var a = "block";
}
console.log(a);

19) In ES5 apart from global scope, the only other scope is function scope, so if we wrote.
function hello() {
    var a = "function";
}
hello();
console.log(a);
If we ran the above we would get an error, like so: Uncaught ReferenceError: a is not defined(…)
This is because the a variable is declared inside a function and is therefore only visible inside that function, trying to access it outside the function results in an error.

20) This issue of no block level scope has plagued JavaScript developers since its inception. One common workaround in the past has been to use something called an Immediately Invoked Function Expression (IIFE) like so:
function hello() {
    var a = "function";

    for (var i=0; i<5; i++) {
        (function() {
            var a = "block";
        })();
    }
    console.log(a);
}
hello();
This now prints out function.

21) If this syntax looks a bit strange to you:
(function() {
    var a = "block";
})();
Know its just a shorter way of writing:
function something() {
  var a = "block";
}
something();
*It’s a function that we call immediately after defining it.

22) Since functions have their own scope, using an IIFE has the same effect as if we had block level scope, the variable a inside the IIFE isn’t visible outside the IIFE. THIS IS COLSURE ALL ABOUT.

23) IIFEs work but it’s a pretty long winded way of solving this problem. So with ES6 we now have the new let keyword, we use it in place of the var keyword and it creates a variable with block level scope, like so:

function hello() {
    var a = "function";
    for (var i = 0; i < 5; i++) {
        let a = "block";
    }
    console.log(a);
}
hello();
- Now the a declared in the for loop body only exists between the { and }, and the code snippet above prints out function as expected.

24) Even though let i = 0 is strictly declared outside of the for block { }, any variables declared in the for loop expression with let has block level scope in the for loop.
var funcs = [];
for (let i = 0; i < 5; i += 1) {
    funcs.push(function () {
        console.log(i);
    })
}
funcs.forEach(function (func) {
    func()
});

25) unless you have a specific reason to use var I would expect all variables you define from now on to use let.

26) const lets us declare variables which don’t change over time, which are immutable.

* 27) The important gotcha with const is that the variable is immutable, but not the value, the thing the variable points to.

* 28) This means that if we declare an object as const, confusingly we can still change properties of the object later on.

29) To solve this and make an object immutable we use the Object.freeze(…​) function which together with the "use strict"; param throws an error if we try to change the object.

ES6 JavaScript & TypeScript - Template Strings
30）With ES5 and ES6 we can specify a string with either the ' or " characters. In ES6 we have another way of defining strings, using the back-tick character `
let multi = `
hello
world
my
name
is
asim`;
console.log(multi);

31） Another really interesting feature of declaring strings with ` is that they can now expand variables using the ${variable_name} syntax, like so:

let name = "asim";
let multi = `
hello
world
my
name
is
${name}
`;
console.log(multi);

32） Template strings are a small change to JavaScript in ES6 but the convenience of multi-line strings and variable substitution is substantial.

#Fat Arrow Functions
33) JavaScript has first class functions. This means that in JavaScript functions can be themselves be passed around like any other value, even as arguments to other functions. E.g. we can pass to the setTimeout function, a function, like so:
setTimeout(function() {
	console.log("setTimeout called!");
}, 1000);

34) The function we pass as an argument to setTimeout is called an anonymous function because it doesn’t have a name.

35) ES6 has introduced a slightly different syntax to define anonymous functions called the fat arrow syntax, with it we can re-write the above as:
setTimeout(() => {
    console.log("setTimeout called!")
}, 1000);

36) If the function only contains one expression we can drop the braces and shorten even further to:
setTimeout(() => console.log("setTimeout called!"), 1000);

37) The new fat arrow function syntax in ES6 is far more than just a slightly shorter way of writing anonymous functions. It has finally solved the thorny issue of stabilising the value of this that has affected javascript since the start and caused so many work arounds to be discussed and applied in code.

#Destrucutring
38) Destructuring is a way of extracting values into variables from data stored in objects and arrays.

39) Object Destructuring
const obj = {first: 'Asim', last: 'Hussain', age: 39 };
const {first: f, last: l} = obj;
console.log(f); // Asim
console.log(l); // Hussain

40) Array Destructuring: Array destructuring works in a similar way except it extracts based of the index in the array, like so:
const arr = ['a', 'b'];
const [x, y] = arr;
console.log(x); // a
console.log(y); // b

41) The for–in loop is for looping over object properties; The for–of loop is for looping over the values in an array; for–of is not just for arrays. It also works on most array-like objects including the new Set and Map types which we will cover in the next lecture.

42) Map is a new data structure introduced in ES6 which lets you map keys to values without the drawbacks of using Objects.
let map = new Map();
map.set("A",1);
map.set("B",2);
map.set("C",3);

The set method is also chainable, like so:

let map = new Map()
    .set("A",1)
    .set("B",2)
    .set("C",3);

let map = new Map([
    [ "A", 1 ],
    [ "B", 2 ],
    [ "C", 3 ]
]);

map.get("A"); // 1
map.has("A"); // true
map.delete("A"); // true
map.size; // 2
map.clear() 
map.size; // 0

for (let key of map.keys()) {
    console.log(key);
}

for (let value of map.values()) {
    console.log(value);
}

43) Sets are a bit like maps but they only store keys not key-value pairs. They are common in other programming languages but are a new addition to JavaScript in ES6.
let set = new Set();
set.add('APPLE');
set.add('ORANGE');
set.add('MANGO');
let set = new Set(['APPLE', 'ORANGE', 'MANGO']);

44) Map and Set are great additions to JavaScript in ES6. We no longer have to deal with Map and Sets poor cousin the Object and it’s many drawbacks.

45) When you execute a task synchronously, you wait for it to finish before moving on to the next line of code. When you execute a task asynchronously, the program moves to the next line of code before the task finishes.

46) A promise is a placeholder for a future value. It serves the same function as callbacks but has a nicer syntax and makes it easier to handle errors.

47) We create an instance of a promise by calling new on the Promise class, like so:
var promise = new Promise((resolve, reject) => {
});

48) JavaScript has a prototype-based, object-oriented programming model. It creates objects using other objects as blueprints and to implement inheritance it manipulates what’s called a prototype chain.

49) We normally call the way object orientation is implemented in C++ or Java as the Classical OO Pattern and the way it’s implemented in JavaScript as the Prototype Pattern. Although the prototype pattern is a valid way to implement object orientation it can be confusing for newer javascript developers or developers used to the classical pattern.

50) A class can inherit from another class. We can create a class blue-print that extends an existing class blue-print by adding other methods or properties.

51) Everything we have learned so far about classes is pure ES6 JavaScript. However TypeScript adds some nice functionality on top of ES6 classes, namely function and property visibility via access modifiers.

52) TypeScript has another feature called an interface. An interface can be used in a number of scenarios but by far the most common is when used with classes.
Human in the example above is an interface. An interface lets you describe the minimum set of public facing properties or methods that a class has. Another way interfaces are explained is that they describe a set of rules the class has to follow, a contract it has to adhere to.
interface Human {
    firstName: string;
    lastName: string;
}

53) If the Person class then doesn’t implement at least a firstName and a lastName then typescript throws an error like so:
error TS2420: Class 'Person' incorrectly implements interface 'Human'. Property 'firstName' is missing in type 'Person'.

54) Sometimes however we might want an interface to describe an optional contract. We can append ? to the name of the property or function to mark it as optional, like so:
interface Human {
    firstName: string;
    lastName: string;
    name?: Function;
    isLate?(time: Date): Function;
}

55) in Angular we can decorate a class with extra info using the @ syntax. This is a new feature that will probably make it into the ES7 version of JavaScript, it’s not available right now however even in the ES6 version. It allows us to decorate classes and functions, similar to annotations in java and decorators in python. the functionality is available in TypeScript

56) Basic Types - We can support boolean, number and string.
let decimal: number = 6;
let done: boolean = false;
let color: string = "blue";

57) Arrays: We have two ways of describing the types of arrays.
let list: number[] = [1, 2, 3];
let list: Array<number> = [1, 2, 3];

58) Functions: We can describe a variable as one that will only point to a function, like so:
let fun: Function = () => console.log("Hello");

59) With TypeScript we can also define the expected return type of a function, like so:
function returnNumber(): number {
  return 1;
}

60) An Enum is a datatype consisting of a set of named values. The names are usually identifiers that behave as constants. Enums were introduced in ES6.
enum Direction {
    Up,
    Down,
    Left,
    Right
}
let go: Direction;
go = Direction.Up;

61) If we don’t know the type of something we can fall back to using any.
let notsure: any = 1;
notsure = "hello"; // This is fine since we don't do type checking with any

62) void means no type, it’s typically used to indicate that a function will not return anything at all, like so:
function returnNothing(): void {
  console.log("Moo");
}

63) like casting in java, Sometimes we end up in a situation where we know more than TypeScript about the type of something. In those situations we can use type assertions as a hint to the transpiler about the type of something, like so:
let value: any = "Asim Hussain";
let length: number = (<string>value).length;

64）With generics we can dynamically generate a new type by passing into the Post type a type variable, like so:
class Post<T> {
    content: T;
}
let videoPost: Post<Video>;

65）By default we don’t have to add types when using TypeScript, we could just leave them out.
let answer;
answer = 42;

66）What if you wanted to use code that wasn’t written in TypeScript or which you are not going to include as TypeScript and compile yourself. We can use something called an ambient type definition. This is a file that contains meta-data about the types in another library, a meta-type file.

#Angular CLI
1) Start an application with ng new: ng new codecraft

2) Serve an application with ng serve: With the CLI we can also easily serve our application using a local web-server. This builds our application, bundles all our code using webpack and makes it all available through localhost:4200. ng serve also watches for any changes to files in our project and auto-reloads the browser for us. The command runs the application through a web-server that support HTML5 push-state routing.

3) Each of the above types of things it can create is called a scaffold. We can run this command using ng generate <scaffold> <name>
Component: ng g component My // Creates MyComponent
Directive: ng g directive My // Creates MyDirective
Pipe: ng g pipe My // Creates MyPipe
Service: ng g service MyService // Creates MyService
Class: ng g class MyClass // Creates MyClass
Interface: ng g interface MyInterface // Creates MyInterface
Enum: ng g enum MyEnum // Creates MyEnum

4) The ng serve command does a great job of enabling development locally. However eventually we will want some code which we can host on another server somewhere. The Angular CLI again has us covered in this regard, if we want to create a development build we simply type
ng build

5) This bundles all our javascript, css, html into a smaller set of files which we can host on another site simply. It outputs these files into the dist folder:

6) By default the ng build command creates a development build, no effort is made to optimise the code. To create a production build we just run: 
ng build --prod

7) Adding a third party module: The build system simplifies the process of serving and releasing your application considerably. It works only because Angular knows about all the files used by your application.

*8) If we want to include a module to use in our Angular javascript code, perhaps we want to to use the moment.js library, we just need to install it via npm like so:
npm install moment --save

*9) If we also want to include the typescript type definition file for our module we can install it via:
npm install @types/moment --save

*10) Global Library Installation: Some javascript libraries need to be added to the global scope, and loaded as if they were in a script tag. We can do this by editing the angular-cli.json file in our project root.

11) First we install the bootstrap library via npm like so: npm install bootstrap@next. Then we add the required javascript files to the app.scripts section or the app.styles in angular-cli.json like so:
"apps": [
    {
       .
      "styles": [
        "styles.css",
        "../node_modules/bootstrap/dist/css/bootstrap.css"
      ],
      "scripts": [
        "../node_modules/jquery/dist/jquery.js",
        "../node_modules/tether/dist/js/tether.js",
        "../node_modules/bootstrap/dist/js/bootstrap.js"
      ],
...

12) The default mechanism for unit testing in Angular is via jasmine and karma. Whenever we generate code via scaffolds it also generates a .spec.ts. The code the CLI bootstraps inside this file depends on the scaffold type but essentially is a jasmine test spec which you can flesh out with more test cases.

13) ng test: This builds our project and then runs all the tests, any errors are output to the terminal. This command also watches for any changes in our files and, if it detects any, re-runs the tests automatically.

14) View Encapsulation: Even though we changed the background color of .card and we have multiple cards on the page only the form component card was rendered with a gray background. Normally if we change a css class the effect is seen throughout an application, something special is happening here and it’s called View Encapsulation.

15) Angular is inspired from Web Components, a core feature of which is the shadow DOM. The shadow DOM lets us include styles into Web Components without letting them leak outside the component’s scope.

16) Angular also provides this feature for Components and we can control it with the encapsulation property. The valid values for this config property are:
ViewEncapsulation.Native
ViewEncapsulation.Emulated
ViewEncapsulation.None

17) ViewEncapsulation.Native: With ViewEncapsulation.Native styles we set on a component do not leak outside of the components scope. However with ViewEncapsulation.Native our component is also isolated from the global styles we’ve defined for our application. 

18) we can design our component with something called content projection to enable it to be customised by the component or developer who is using it.

19) Using life-cycle hooks we can fine tune the behaviour of our components during creation, update and destruction.

20) We use the ngOnInit hook most often, this is where we place any initialisation logic for our component. It’s preferred over initialising via the constructor since in the constructor we don’t yet have access to the input properties whereas by the time ngOnInit is called they have been bound to and are available to use.

21) ngOnChanges is the second most common hook, this is where we can find out details about which input properties have changed and how they have changed.

22) The third most common hook is ngOnDestroy which is where we place any cleanup logic for our component.


23) An Angular application is composed from a number of components nested together. These components can nest in two ways, as view children, in the template for that component. Or they can nest as content children, via content projection from a host component.

24) As developers of our components we can get access to these child components via the @ViewChild and @ContentChild (and @ViewChildren and @ContentChildren) decorators. View children of a component are the components and elements in this components view. Content children of a component are the components and elements that are projected into this components view by a host component.

25) View children are only initialised by the time the AfterViewInit lifecycle phase has been run. Content children are only initialised by the time the AfterContentInit lifecycle phase has been run.

# Directives
1）Directives are components without a view. They are components without a template. Or to put it another way, components are directives with a view.

2) We typically associate directives to existing elements by use attribute selectors, like so:
<elemenent aDirective></element>

3) NgFor is a structural directive, meaning that it changes the structure of the DOM.
<ul> 
  <li *ngFor="let person of people; let i = index"> 
    {{ i + 1 }} - {{ person.name }} 
  </li>
</ul>

4) With NgIf we can conditionally add or remove an element from the DOM.
<ul *ngFor="let person of people">
  <li *ngIf="person.age < 30"> 
  {{ person.name }} ({{ person.age }})
  </li>
</ul>

5) If we are faced with multiple conditions a cleaner alternative to multiple nested NgIf statements is the NgSwitch series of directives.
<ul *ngFor="let person of people"
    [ngSwitch]="person.country"> 
  <li *ngSwitchCase="'UK'" 
      class="text-success">{{ person.name }} ({{ person.country }})
  </li>
  <li *ngSwitchCase="'USA'"
      class="text-primary">{{ person.name }} ({{ person.country }})
  </li>
  <li *ngSwitchCase="'HK'"
      class="text-danger">{{ person.name }} ({{ person.country }})
  </li>
  <li *ngSwitchDefault 
      class="text-warning">{{ person.name }} ({{ person.country }})
  </li>
</ul>`

6) Both the NgStyle and NgClass directives can be used to conditionally set the look and feel of your application.

7) NgStyle gives you fine grained control on individual properties. 
<ul *ngFor="let person of people">
  <li [ngStyle]="{'color':getColor(person.country)}"> {{ person.name }} ({{ person.country }}) 
  </li>
</ul>

8) But if you want to make changes to multiple properties at once, creating a class which bundles those properties and adding the class with NgClass makes more sense.
<ul *ngFor="let person of people">
  <li [ngClass]="{
    'text-success':person.country === 'UK',
    'text-primary':person.country === 'USA',
    'text-danger':person.country === 'HK'
  }">{{ person.name }} ({{ person.country }})
  </li>
</ul>


9) We use NgNonBindable when we want to tell Angular not to perform any binding for an element.
<div>
  To render the name variable we use this syntax <pre ngNonBindable>{{ name }}</pre>
</div>

#Http
1) In JavaScript making HTTP requests is an asynchronous operation. It just sends the HTTP request to the API and doesn’t wait for a response before continuing with the next line of code.

2) In Angular there are two ways of handling these asynchronous operations. We can use Promises which we covered in the lecture on TypeScript & ES6, or we can use Observables which we covered in the section on RxJS and Observables.

#Routing
1) Another way to think about the URL in your address bar is that it defines the current state of your application.

2) State is a computer science terms and means "all the stored information, at a given instant in time, to which program has access". So the state of an application is the current value of all the variables in the application. An address in a URL can’t store that much information but it can store enough so that perhaps we can re-fetch some and re-calculate the rest to get to the same state as before.

3) Giving the a URL to someone else should enable them to bring up the same state in their browser. In traditional applications built with Server Side Routing when you change the URL in your browser, the browser makes a request to the server to return some HTML which it will display.

4) However we want to implement something called Client Side Routing. When the URL changes in the browser we want our local application that’s running in the browser (the client) to handle the change, we don’t want the request sent to the server.

5) When we first navigate to a new site the server returns the html, javascript and css needed to render that page. All further changes to the URL are handled locally by the client application. Typically the client application will make one or more API requests to get the information it needs to show the new page.

6) Angular has a couple of modules which let us implement our application as an SPA, the concept as a whole in Angular is called the Component Router.

7) First we need to setup some imports, like so:
import {Routes, RouterModule} from "@angular/router";

8) The mapping of URLs to Components we want displayed on the page is done via something called a Route Configuration, at it’s core it’s just an array which we can define like so:
const routes: Routes = [
 { path: '', component: HomeComponent },
 { path: 'search', component: SearchComponent }
];

9)We then install these routes into our application by importing RouterModule.forRoot(routes) into our NgModule, like so:
@NgModule({
	imports: [
	 .
		RouterModule.forRoot(routes, {useHash: true})
	]
	.
})
class AppModule { }
- {useHash: true} argument prepends /# to all of our urls, so our root url would be /#/ and our search url would be /#/search

10) We need to add a directive called router-outlet somewhere in our template HTML. This directive tells Angular where it should insert each of those components in the route
<div class="m-t-1">
  <router-outlet></router-outlet> 
</div>

11) The redirectTo property describes the path we want to redirect this user to if they navigate to this URL. We can also add a catch all route by using the path **, if the URL doesn’t match any of the other routes it will match this route.
const routes:Routes = [
	{path: '', redirectTo: 'home', pathMatch: 'full'},
	{path: 'find', redirectTo: 'search'},
	{path: 'home', component: HomeComponent},
	{path: 'search', component: SearchComponent},
	{path: '**', component: HomeComponent} 
];

12) Navigating by hardcoded URLS: We could simply hardcode the URLs in the href anchor attributes on our navigation header, like so:
We simply add a standard href with a value of /#/
<ul class="nav navbar-nav">
    <li class="nav-item active">
      <a class="nav-link" href="/#/">Home</a> 
    </li>
    <li class="nav-item">
      <a class="nav-link" href="/#/search">Search</a>
    </li>
 </ul>

 13) Navigating programmatically via the router: In Angular we can also programmatically navigate via a Router service we inject into our component, like so:
 <ul class="nav navbar-nav">
    <li class="nav-item">
      <a class="nav-link" (click)="goHome()">Home</a> 
    </li>
    <li class="nav-item">
      <a class="nav-link" (click)="goSearch()">Search</a> 
    </li>
  </ul>

  constructor(private router: Router) {} 

  goHome() {
    this.router.navigate(['']); 
  }

  goSearch() {
    this.router.navigate(['search']); 
  }

14) Link params array: The value we pass into the navigate function might look a bit strange, we call it a link params array and it equivalent to the URL split by the / character into an array.

15) Navigating via a link params array has one big advantage in that parts of the URL can be variables, like so:
let part = "foo";
this.router.navigate(['search', part, 'moo']);

16) Navigating via a routerLink directive: We can also control navigation by using the routerLink directive in the template itself, like so:
<li class="nav-item active">
      <a class="nav-link"  [routerLink]="['home']">Home</a>
    </li>
    <li class="nav-item">
      <a class="nav-link"  [routerLink]="['search']">Search</a>
    </li>
- The routerLink directive takes as input the same link params array format that the router.navigate(…​) function takes.

17) With the twitter bootstrap navigation styles we give this feedback by adding a class of active to the parent element to the anchor tag, like so: 
<a class="nav-link"
   [routerLink]="['home']"
   [routerLinkActive]="['active']">
   Home
</a>
- The above will add a class of active to the anchor tag if we are currently viewing the home route.

18) parameterised route and we would implement it like so:
const routes: Routes = [
 { path: 'blog/:id', component: BlogComponent } 
];
The path has a variable called id, we know it’s a variable since it begins with a colon : A path can have any number of variables as long as they all start with : and have different names.

19）So how do we pass into BlogComponent the value of the id variable? If we visited /blog/1 how does BlogComponent know the id is 1 and therefore to show the appropriate article. To do that we use something called an ActivatedRoute. We import it first and then inject it into the constructor of BlogComponent. It exposes an Observable which we can subscribe to, like so:
import {ActivatedRoute} from "@angular/router";
.
.
.
constructor(private route: ActivatedRoute) {
    this.route.params.subscribe( params => console.log(params) );
}

constructor(private itunes:SearchService,
            private route: ActivatedRoute) {
  this.route.params.subscribe( params => this.doSearch(params['term'])); 
}

20）When using routing if some part of the state of your application is in the URL then you need to update your application by navigating to the URL. That way the URL matches the state of your app and if you bookmarked or shared the URL then visiting it again would get you back to the same state.

21） navigate to the appropriate search URL and then let the ActivatedRoute service notify the SearchComponent the route changed and let that perform the search. This way the URL changes every-time we do a search.
<button type="button"
        class="btn btn-primary"
        (click)="onSearch(search.value)">
        Search
</button>
onSearch(term:string) {
  this.router.navigate(['search', term]); 
}

22）The concept of having two sets of menu items. A top level between Home, Search and Artist and a second level under Artist between Tracks and Albums is called Nested Routing and it’s the topic of this lecture.

23）"Inside the ArtistComponent I want to conditionally show either the AritstAlbumsListComponent or the ArtistTrackListComponent depending on which menu item the user has selected".
const routes: Routes = [
  {path: '', redirectTo: 'home', pathMatch: 'full'},
  {path: 'find', redirectTo: 'search'},
  {path: 'home', component: HomeComponent},
  {path: 'search', component: SearchComponent},
  {
    path: 'artist/:artistId',
    component: ArtistComponent,
    children: [
      {path: '', redirectTo: 'tracks'}, 
      {path: 'tracks', component: ArtistTrackListComponent}, 
      {path: 'albums', component: ArtistAlbumListComponent}, 
    ]
  },
  {path: '**', component: HomeComponent}
];

<h1>Artist</h1>
<p>
  <a [routerLink]="['./tracks']">Tracks</a> |
  <a [routerLink]="['./albums']">Albums</a>
</p>
<router-outlet></router-outlet>

#Route guard
1) With guards we can add checks to restrict access to a user to certain pages on our site.

2) Depending on the type of guard the guard function also has some arguments passed to it which we can take advantage of if we want, namely the future ActivatedRoute and the future RouterState and for CanDeactivate guards we also have the ability to get the component itself.

3) Guards themselves are just classes and as such can have any other dependencies injected into their constructor so can work in conjunction with other services to figure out if the guard passes or fails.

4) Guard functions can return either a boolean or an Observable<boolean> or Promise<boolean> which resolves to a boolean at some point in the future.

5) A route can be configured with multiple guards and the guards are checked in the order they were added to the route.

#Path Strategies.
1) The default client side routing strategy used in Angular is the PathLocationStrategy.

2) This changes the URL programmatically using the HTML5 History API in such a way that the browser doesn’t make a request to the server for the new URL.

3) For this to work we do need to serve our Angular application from a server that supports requests on multiple different URLs, at a minimum all this server side needs to do is return the same page for all the different URLs that’s requested from it. It’s not a lot of work but does need some co-operation from the server side.

4) PathLocationStrategy also sets us up for a future architecture where we can speed up loading time by pre-rendering the pages with Angular running on the server side and then once it’s downloaded to the browser the client can take over routing. This is called Angular Universal and it’s currently in development.

5) HashLocationStrategy uses the hash fragment part of the URL to store state for the client, it easier to setup and doesn’t require any co-operation from the server side but has the downside that it won’t work with Angular Universal once that’s released.

#Model Driven Forms
1) Whether we are template driven or model driven we need some basic form HTML to begin with.
<form novalidate>
  <fieldset>
    <div class="form-group">
      <label>First Name</label>
      <input type="text"
             class="form-control">
    </div>

    <div class="form-group">
      <label>Last Name</label>
      <input type="text"
             class="form-control">
    </div>
  </fieldset>

  <div class="form-group">
    <label>Email</label>
    <input type="email"
           class="form-control">
  </div>

  <div class="form-group">
    <label>Password</label>
    <input type="password"
           class="form-control">
  </div>

  <div class="form-group">
    <label>Language</label>
    <select class="form-control">
      <option value="">Please select a language</option>
    </select>
  </div>
</form>

2) We’ve added the novalidate attribute to the form element, by default browsers perform their own validation and show their own error popups. Since we want to handle the form validation ourselves we can switch off this behaviour by adding novalidate to the form element.

3) We represent the form as a model composed of instances of FormGroups and FormControls.
import { FormGroup, FormControl } from '@angular/forms';
class ModelFormComponent implements OnInit {
  myform: FormGroup; 

  ngOnInit() {
    myform = new FormGroup({
        name: new FormGroup({ 
            firstName: new FormControl(), 
            lastName: new FormControl(),
        }),
        email: new FormControl(),
        password: new FormControl(),
        language: new FormControl()
    });
  }
}

3) myform is an instance of FormGroup and represents the form itself. FormGroups can nest inside other FormGroups. We create a FormControl for each template form control.

4) Like the FormControl instance, FormGroup instances encapsulates the state of all of it’s inner controls, for example an instance of a FormGroup is valid only if all of it’s inner controls are also valid.

5) Linking the form model to the form template: We do this using a number of directives which are found in the ReactiveFormsModule, so lets import that and add it to the imports on our NgModule.
import { ReactiveFormsModule } from '@angular/forms';

6) Firstly we bind the <form> element to our top level myform property using the formGroup directive, like so
<form [formGroup]="myform"> ... </form>

7) The value property of the myform model returns the values of all of the controls as an object. We can use that with the json pipe to output some useful debug information about our form, like so:
<pre>{{myform.value | json}}</pre>

8) link each form control in the model with each form control in the template, we need to do this explicitly with the formControlName and formGroupName directives.

9) We use the formControlName directive to map each form control in the template with a named form control in the model, like so:
<div class="form-group">
  <label>Email</label>
  <input type="email"
         class="form-control"
         formControlName="email" 
         required>
</div>


