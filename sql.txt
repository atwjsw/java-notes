W3schools database tutorials
1) SELECT * FROM Customers; 
2) select * from Orders o, Employees e where o.employeeId = e.employeeId (查看所有Order对应的Employee信息)
3) select * from Orders o, Customers c where o.customerId = c.customerId (查看所有Order对应的Customer信息)
4) select * from Orders o, OrderDetails od where o.orderId = od.orderId (查看所有Order对应的OrderDetails信息)
5) select * from Orders o, OrderDetails od where o.orderId = od.orderId and o.orderId = 10248 (查看某一Order及对应的Customer信息)
6) select * from Products p, OrderDetails od where p.productId = od.productId (查看所有Product对应OrderDetails信息)
7) select p.productId, od.orderDetailId from Products p, OrderDetails od where p.productId = od.productId order by p.productId, od.orderDetailId
8) select p.productId, count(od.orderDetailId) from Products p, OrderDetails od where p.productId = od.productId group by p.productId (每个proudct有多少product details
9) select p.productId, count(od.orderDetailId) from Products p, OrderDetails od where p.productId = od.productId group by p.productId order by p.productId desc  每个proudct有多少product details, 倒序
10) select o.orderId, od.orderDetailId from Orders o, OrderDetails od where o.orderId = od.orderId and o.orderId = 10248
11) certain order includes what proudcts?
select p.productId, o.orderId, od.orderDetailId 
from Products p, Orders o, OrderDetails od 
where p.productId = od.productId
and o.orderId = od.orderId
and o.orderId = 10248
12) certain product are included in what orders?
select p.productId, p.productName, o.orderId, od.orderDetailId 
from Products p, Orders o, OrderDetails od 
where p.productId = od.productId
and o.orderId = od.orderId
and p.productId = 1
13) Certain product are sold to what customers?
select p.productId, p.productName, o.orderId, od.orderDetailId, c.customerId, c.customerName 
from Products p, Orders o, OrderDetails od, Customers c 
where p.productId = od.productId
and o.orderId = od.orderId
and o.customerId = c.customerId
and p.productId = 1

14) Although SQL is an ANSI (American National Standards Institute) standard, there are different versions of the SQL language.
15) Most of the SQL database programs also have their own proprietary extensions in addition to the SQL standard!
16） A table is a collection of related data entries and it consists of columns and rows.
17） Every table is broken up into smaller entities called fields. A field is a column in a table that is designed to maintain specific information about every record in the table.
18) A record, also called a row, is each individual entry that exists in a table.
19) SQL keywords are NOT case sensitive: select is the same as SELECT
20) Some database systems require a semicolon at the end of each SQL statement. Semicolon is the standard way to separate each SQL statement in database systems that allow more than one SQL statement to be executed in the same call to the server.

21) Some of The Most Important SQL Commands
SELECT - extracts data from a database
UPDATE - updates data in a database
DELETE - deletes data from a database
INSERT INTO - inserts new data into a database
CREATE DATABASE - creates a new database
ALTER DATABASE - modifies a database
CREATE TABLE - creates a new table
ALTER TABLE - modifies a table
DROP TABLE - deletes a table
CREATE INDEX - creates an index (search key)
DROP INDEX - deletes an index

22) The SELECT DISTINCT statement is used to return only distinct (different) values.
- Inside a table, a column often contains many duplicate values; and sometimes you only want to list the different (distinct) values.
SELECT DISTINCT Country FROM Customers;
SELECT COUNT(DISTINCT Country) FROM Customers;

23) The WHERE clause is used to extract only those records that fulfill a specified condition.

24) Text Fields vs. Numeric Fields: SQL requires single quotes around text values (most database systems will also allow double quotes). However, numeric fields should not be enclosed in quotes:

25) Operators in The WHERE Clause:
Operator	Description
=			Equal
<>			Not equal. Note: In some versions of SQL this operator may be written as !=
>			Greater than
<			Less than
>=			Greater than or equal
<=			Less than or equal
BETWEEN		Between an inclusive range
LIKE		Search for a pattern
IN			To specify multiple possible values for a column

26) The WHERE clause can be combined with AND, OR, and NOT operators. The AND and OR operators are used to filter records based on more than one condition:
- The AND operator displays a record if all the conditions separated by AND is TRUE.
- The OR operator displays a record if any of the conditions separated by OR is TRUE.
- The NOT operator displays a record if the condition(s) is NOT TRUE.

27) Combining AND, OR and NOT
SELECT * FROM Customers
WHERE Country='Germany' AND (City='Berlin' OR City='München');
SELECT * FROM Customers
WHERE NOT Country='Germany' AND NOT Country='USA';

28) The ORDER BY keyword is used to sort the result-set in ascending or descending order.
SELECT * FROM Customers
ORDER BY Country ASC, CustomerName DESC;

29) INSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country)
VALUES ('Cardinal', 'Tom B. Erichsen', 'Skagen 21', 'Stavanger', '4006', 'Norway');

30) If a field in a table is optional, it is possible to insert a new record or update a record without adding a value to this field. Then, the field will be saved with a NULL value.

31) How to Test for NULL Values? 
It is not possible to test for NULL values with comparison operators, such as =, <, or <>. We will have to use the IS NULL and IS NOT NULL operators instead.

32) The SQL SELECT TOP Clause
The SELECT TOP clause is used to specify the number of records to return. The SELECT TOP clause is useful on large tables with thousands of records. Returning a large number of records can impact on performance.

33）The SELECT TOP clause is used to specify the number of records to return. The SELECT TOP clause is useful on large tables with thousands of records. Returning a large number of records can impact on performance.
- SELECT TOP 3 * FROM Customers;
- SELECT * FROM Customers
LIMIT 3;
- SELECT * FROM Customers
WHERE ROWNUM <= 3;
- SELECT TOP 50 PERCENT * FROM Customers;
- SELECT * FROM Customers
WHERE Country='Germany'
LIMIT 3;

34） The MIN() function returns the smallest value of the selected column. The MAX() function returns the largest value of the selected column.
SELECT MIN(Price) AS SmallestPrice
FROM Products;
- applicale to VARCHAR

35) The COUNT() function returns the number of rows that matches a specified criteria.
SELECT COUNT(ProductId)
FROM Products;

36) The AVG() function returns the average value of a numeric column.
SELECT AVG(Price)
FROM Products;

37) The SUM() function returns the total sum of a numeric column.
SELECT SUM(Quantity)
FROM OrderDetails;

38）The LIKE operator is used in a WHERE clause to search for a specified pattern in a column. There are two wildcards used in conjunction with the LIKE operator:
% - The percent sign represents zero, one, or multiple characters
_ - The underscore represents a single character
LIKE Operator					Description
WHERE CustomerName LIKE 'a%'	Finds any values that starts with "a"
WHERE CustomerName LIKE '%a'	Finds any values that ends with "a"
WHERE CustomerName LIKE '%or%'	Finds any values that have "or" in any position
WHERE CustomerName LIKE '_r%'	Finds any values that have "r" in the second position
WHERE CustomerName LIKE 'a_%_%'	Finds any values that starts with "a" and are at least 3 characters in length
WHERE ContactName LIKE 'a%o'	Finds any values that starts with "a" and ends with "o"

MySQL:
SELECT DISTINCT city FROM station where City regexp '[aeiou]$'; -- ending with aeiou
SELECT DISTINCT city FROM station WHERE city REGEXP "^[aeiou]"; -- starting with aeiou

39) Using the [charlist] Wildcard: The following SQL statement selects all customers with a City starting with "b", "s", or "p":
- SELECT * FROM Customers
WHERE City LIKE '[bsp]%';
- SELECT * FROM Customers
WHERE City LIKE '[a-c]%';
- SELECT * FROM Customers
WHERE City LIKE '[!bsp]%';
- SELECT * FROM Customers
WHERE City NOT LIKE '[bsp]%';  //effect same as above


40) The IN operator allows you to specify multiple values in a WHERE clause. The IN operator is a shorthand for multiple OR conditions.
SELECT * FROM Customers
WHERE Country IN ('Germany', 'France', 'UK');
SELECT * FROM Customers
WHERE Country NOT IN ('Germany', 'France', 'UK');
SELECT * FROM Customers
WHERE Country IN (SELECT Country FROM Suppliers);

41) The BETWEEN operator selects values within a given range. The values can be numbers, text, or dates. The BETWEEN operator is inclusive: begin and end values are included. 
SELECT * FROM Products
WHERE Price BETWEEN 10 AND 20;

- The following SQL statement selects all products with a price BETWEEN 10 and 20. In addition; do not show products with a CategoryID of 1,2, or 3:
SELECT * FROM Products
WHERE (Price BETWEEN 10 AND 20)

42) BETWEEN Text Values Example: The following SQL statement selects all products with a ProductName BETWEEN 'Carnarvon Tigers' and 'Mozzarella di Giovanni':
AND NOT CategoryID IN (1,2,3);

43) BETWEEN Dates Example: The following SQL statement selects all orders with an OrderDate BETWEEN '04-July-1996' and '09-July-1996':
SELECT * FROM Orders
WHERE OrderDate BETWEEN #07/04/1996# AND #07/09/1996#;

44) SQL aliases are used to give a table, or a column in a table, a temporary name. Aliases are often used to make column names more readable. An alias only exists for the duration of the query.
SELECT CustomerID as ID, CustomerName AS Customer
FROM Customers;

45) The following SQL statement creates two aliases, one for the CustomerName column and one for the ContactName column. Note: It requires double quotation marks or square brackets if the alias name contains spaces:
SELECT CustomerName AS Customer, ContactName AS [Contact Person]
FROM Customers;

46）
SELECT CustomerName, Address + ', ' + PostalCode + ' ' + City + ', ' + Country AS Address
FROM Customers;

47) To get the SQL statement above to work in MySQL use the following:
SELECT CustomerName, CONCAT(Address,', ',PostalCode,', ',City,', ',Country) AS Address
FROM Customers;

48) SQL JOIN
A JOIN clause is used to combine rows from two or more tables, based on a related column between them.
Then, we can create the following SQL statement (that contains an INNER JOIN), "that selects records that have matching values in both tables":
- SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
FROM Orders
INNER JOIN Customers ON Orders.CustomerID=Customers.CustomerID;

49) Different Types of SQL JOINs
(INNER) JOIN: Returns records that have matching values in both tables

SELECT Orders.OrderID, Customers.CustomerName
FROM Orders
INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;

SELECT Orders.OrderID, Customers.CustomerName, Shippers.ShipperName
FROM ((Orders
INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID)
INNER JOIN Shippers ON Orders.ShipperID = Shippers.ShipperID);

50) LEFT (OUTER) JOIN: returns all records from the left table (table1), and the matched records from the right table (table2). The result is NULL from the right side, if there is no match.
SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
LEFT JOIN Orders
ON Customers.CustomerID=Orders.CustomerID
ORDER BY Customers.CustomerName;

51) RIGHT (OUTER) JOIN: Return all records from the right table, and the matched records from the left table. The result is NULL from the left side, when there is no match.
SELECT Orders.OrderID, Employees.LastName, Employees.FirstName
FROM Orders
RIGHT JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID
ORDER BY Orders.OrderID;

52) FULL (OUTER) JOIN: Return all records when there is a match in either left or right table
SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
FULL OUTER JOIN Orders ON Customers.CustomerID=Orders.CustomerID
ORDER BY Customers.CustomerName;

53) A self JOIN is a regular join, but the table is joined with itself. The following SQL statement matches customers that are from the same city:
SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2, A.City
FROM Customers A, Customers B
WHERE A.CustomerID <> B.CustomerID
AND A.City = B.City 
ORDER BY A.City;

53) This can be useful when modeling hierarchies. They are also useful for comparisons within a table.

54) The UNION operator is used to combine the result-set of two or more SELECT statements.
Each SELECT statement within UNION must have the same number of columns
The columns must also have similar data types
The columns in each SELECT statement must also be in the same order
- SELECT City FROM Customers
UNION
SELECT City FROM Suppliers
ORDER BY City;

55) The UNION operator selects only distinct values by default. To allow duplicate values, use UNION ALL:
- SELECT City FROM Customers
UNION ALL
SELECT City FROM Suppliers
ORDER BY City;

55) SQL Subqueries: A subquery is a SQL query within a query. Subqueries are nested queries that provide data to the enclosing query. Subqueries can return individual values or a list of records. Subqueries must be enclosed with parenthesis:
SELECT ProductName
  FROM Product 
 WHERE Id IN (SELECT ProductId 
                FROM OrderItem
               WHERE Quantity > 100)

SELECT FirstName, LastName, 
       OrderCount = (SELECT COUNT(O.Id) FROM [Order] O WHERE O.CustomerId = C.Id)
FROM Customer C 

55) SQL WHERE ANY, ALL Clause: ANY and ALL keywords are used with a WHERE or HAVING clause. ANY and ALL operate on subqueries that return multiple values.
ANY returns true if any of the subquery values meet the condition. ALL returns true if all of the subquery values meet the condition.
SELECT ProductName
  FROM Product
 WHERE Id = ANY
       (SELECT ProductId 
          FROM OrderItem 
         WHERE Quantity = 1)

SELECT DISTINCT FirstName + ' ' + LastName as CustomerName
  FROM Customer, [Order]
 WHERE Customer.Id = [Order].CustomerId
   AND TotalAmount > ALL 
       (SELECT AVG(TotalAmount)
          FROM [Order]
         GROUP BY CustomerId)

55) SQL WHERE EXISTS Statement: WHERE EXISTS tests for the existence of any records in a subquery. EXISTS returns true if the subquery returns one or more records. EXISTS is commonly used with correlated subqueries.
SELECT CompanyName
  FROM Supplier
 WHERE EXISTS
       (SELECT ProductName
          FROM Product
         WHERE SupplierId = Supplier.Id 
           AND UnitPrice > 100)	
- This is a correlated subquery because the subquery references the enclosing query (with Supplier.Id). 

56) The GROUP BY statement is often used with aggregate functions (COUNT, MAX, MIN, SUM, AVG) to group the result-set by one or more columns.
SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country;

SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
ORDER BY COUNT(CustomerID) DESC;

SELECT Shippers.ShipperName,COUNT(Orders.OrderID) AS NumberOfOrders FROM Orders
LEFT JOIN Shippers ON Orders.ShipperID = Shippers.ShipperID
GROUP BY ShipperName;

57) The HAVING clause was added to SQL because the WHERE keyword could not be used with aggregate functions.
SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
HAVING COUNT(CustomerID) > 5
ORDER BY COUNT(CustomerID) DESC;

SELECT Employees.LastName, COUNT(Orders.OrderID) AS NumberOfOrders
FROM (Orders
INNER JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID)
GROUP BY LastName
HAVING COUNT(Orders.OrderID) > 10;

58) The EXISTS operator is used to test for the existence of any record in a subquery. The EXISTS operator returns true if the subquery returns one or more records.
The following SQL statement returns TRUE and lists the suppliers with a product price less than 20:

SELECT SupplierName
FROM Suppliers
WHERE EXISTS (SELECT ProductName FROM Products WHERE SupplierId = Suppliers.supplierId AND Price < 20);

59) The ANY and ALL operators are used with a WHERE or HAVING clause. The ANY operator returns true if any of the subquery values meet the condition.
The ALL operator returns true if all of the subquery values meet the condition.

SELECT ProductName
FROM Products
WHERE ProductID = ANY (SELECT ProductID FROM OrderDetails WHERE Quantity = 10);

SELECT ProductName
FROM Products
WHERE ProductID = ALL (SELECT ProductID FROM OrderDetails WHERE Quantity = 10);

60) The SELECT INTO statement copies data from one table into a new table.
SELECT * INTO CustomersBackup2017
FROM Customers;

SELECT * INTO SupplierUSA
  FROM Supplier
 WHERE Country = 'USA'

61) The following SQL statement uses the IN clause to copy the table into a new table in another database:
SELECT * INTO CustomersBackup2017 IN 'Backup.mdb'
FROM Customers;

61) CASE statementN
SELECT CASE WHEN (a+b <= c OR a+c <= b OR b+c <= a) THEN "Not A Triangle"
    WHEN (a=b AND b=c) THEN "Equilateral"
    WHEN (a=b OR b=c OR a=c) THEN "Isosceles"
    ELSE "Scalene" END
FROM TRIANGLES

SELECT MAX(POPULATION) - MIN(POPULATION)
FROM CITY;

62) The INSERT INTO SELECT statement copies data from one table and inserts it into another table.
INSERT INTO SELECT requires that data types in source and target tables match; The existing records in the target table are unaffected
INSERT INTO Customers (CustomerName, City, Country)
SELECT SupplierName, City, Country FROM Suppliers;

INSERT INTO Customer (FirstName, LastName, City, Country, Phone)
SELECT LEFT(ContactName, CHARINDEX(' ',ContactName) - 1) AS FirstName, 
       SUBSTRING(ContactName, CHARINDEX(' ',ContactName) + 1, 100) AS LastName, 
       City, Country, Phone
  FROM Supplier
 WHERE Country = 'Canada'

63) SQL IFNULL(), ISNULL(), COALESCE(), and NVL() Functions
- The MySQL IFNULL() function lets you return an alternative value if an expression is NULL:
SELECT ProductName, UnitPrice * (UnitsInStock + IFNULL(UnitsOnOrder, 0))
FROM Products

- or we can use the COALESCE() function, like this:
SELECT ProductName, UnitPrice * (UnitsInStock + COALESCE(UnitsOnOrder, 0))
FROM Products

64) Comments are used to explain sections of SQL statements, or to prevent execution of SQL statements.

65) Single line comments start with --. Any text between -- and the end of the line will be ignored (will not be executed).
--Select all:
SELECT * FROM Customers;
SELECT * FROM Customers -- WHERE City='Berlin';

66) Multi-line comments start with /* and end with */. Any text between /* and */ will be ignored.
SELECT CustomerName, /*City,*/ Country FROM Customers;
/*SELECT * FROM Customers;
SELECT * FROM Products;
SELECT * FROM Orders;
SELECT * FROM Categories;*/
SELECT * FROM Suppliers;

67) The CREATE DATABASE statement is used to create a new SQL database. 
CREATE DATABASE testDB;
SHOW DATABASES;
DROP DATABASE databasename;

68) CREATE TABLE
CREATE TABLE Persons (
    PersonID int,
    LastName varchar(255),
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255) 
);
The datatype parameter specifies the type of data the column can hold (e.g. varchar, integer, date, etc.).

69) DROP TABLE Shippers;

70) The TRUNCATE TABLE statement is used to delete the data inside a table, but not the table itself.
TRUNCATE TABLE table_name;

71) The ALTER TABLE statement is used to add, delete, or modify columns in an existing table. The ALTER TABLE statement is also used to add and drop various constraints on an existing table.

72) To add a column in a table:
ALTER TABLE Persons
ADD DateOfBirth date;

73) To delete a column in a table:
ALTER TABLE Persons
DROP COLUMN DateOfBirth;

74) To change the data type of a column in a table,
ALTER TABLE Persons
ALTER COLUMN DateOfBirth year;

75) SQL constraints are used to specify rules for data in a table.

76) SQL constraints are used to specify rules for the data in a table. Constraints are used to limit the type of data that can go into a table. This ensures the accuracy and reliability of the data in the table. If there is any violation between the constraint and the data action, the action is aborted.

77) Constraints can be column level or table level. Column level constraints apply to a column, and table level constraints apply to the whole table.

78) The following constraints are commonly used in SQL:
NOT NULL - Ensures that a column cannot have a NULL value
UNIQUE - Ensures that all values in a column are different
PRIMARY KEY - A combination of a NOT NULL and UNIQUE. Uniquely identifies each row in a table
FOREIGN KEY - Uniquely identifies a row/record in another table
CHECK - Ensures that all values in a column satisfies a specific condition
DEFAULT - Sets a default value for a column when no value is specified
INDEX - Used to create and retrieve data from the database very quickly

79) Constraints can be specified when the table is created with the CREATE TABLE statement, or after the table is created with the ALTER TABLE statement.

80) By default, a column can hold NULL values. The NOT NULL constraint enforces a column to NOT accept NULL values.
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255) NOT NULL,
    Age int
);

81) The UNIQUE constraint ensures that all values in a column are different. Both the UNIQUE and PRIMARY KEY constraints provide a guarantee for uniqueness for a column or set of columns.
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    UNIQUE (ID)
);

82) To name a UNIQUE constraint, and to define a UNIQUE constraint on multiple columns, use the following SQL syntax:
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    CONSTRAINT UC_Person UNIQUE (ID,LastName)
);

83) To create a UNIQUE constraint on the "ID" column when the table is already created, use the following SQL:
ALTER TABLE Persons
ADD UNIQUE (ID);

84) To name a UNIQUE constraint, and to define a UNIQUE constraint on multiple columns, use the following SQL syntax:
ALTER TABLE Persons
ADD CONSTRAINT UC_Person UNIQUE (ID,LastName);

85) DROP a UNIQUE Constraint
ALTER TABLE Persons
DROP INDEX UC_Person;

86) The PRIMARY KEY constraint uniquely identifies each record in a database table. Primary keys must contain UNIQUE values, and cannot contain NULL values. A table can have only one primary key, which may consist of single or multiple fields.

87) The following SQL creates a PRIMARY KEY on the "ID" column when the "Persons" table is created:
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    PRIMARY KEY (ID)
);

88) To allow naming of a PRIMARY KEY constraint, and for defining a PRIMARY KEY constraint on multiple columns, use the following SQL syntax:
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    CONSTRAINT PK_Person PRIMARY KEY (ID,LastName)
);
- In the example above there is only ONE PRIMARY KEY (PK_Person). However, the VALUE of the primary key is made up of TWO COLUMNS (ID + LastName).


89) To create a PRIMARY KEY constraint on the "ID" column when the table is already created, use the following SQL:
ALTER TABLE Persons
ADD PRIMARY KEY (ID);

90) To allow naming of a PRIMARY KEY constraint, and for defining a PRIMARY KEY constraint on multiple columns, use the following SQL syntax:
ALTER TABLE Persons
ADD CONSTRAINT PK_Person PRIMARY KEY (ID,LastName);


91) To drop a PRIMARY KEY constraint, use the following SQL:
ALTER TABLE Persons
DROP PRIMARY KEY;

92) A FOREIGN KEY is a key used to link two tables together. A FOREIGN KEY is a field (or collection of fields) in one table that refers to the PRIMARY KEY in another table. The table containing the foreign key is called the child table, and the table containing the candidate key is called the referenced or parent table.

93) The FOREIGN KEY constraint is used to prevent actions that would destroy links between tables. The FOREIGN KEY constraint also prevents invalid data from being inserted into the foreign key column, because it has to be one of the values contained in the table it points to.

94) The following SQL creates a FOREIGN KEY on the "PersonID" column when the "Orders" table is created: 
CREATE TABLE Orders (
    OrderID int NOT NULL,
    OrderNumber int NOT NULL,
    PersonID int,
    PRIMARY KEY (OrderID),
    FOREIGN KEY (PersonID) REFERENCES Persons(PersonID)
);

95) To allow naming of a FOREIGN KEY constraint, and for defining a FOREIGN KEY constraint on multiple columns, use the following SQL syntax:
CREATE TABLE Orders (
    OrderID int NOT NULL,
    OrderNumber int NOT NULL,
    PersonID int,
    PRIMARY KEY (OrderID),
    CONSTRAINT FK_PersonOrder FOREIGN KEY (PersonID)
    REFERENCES Persons(PersonID)
);

96) To create a FOREIGN KEY constraint on the "PersonID" column when the "Orders" table is already created, use the following SQL:
ALTER TABLE Orders
ADD FOREIGN KEY (PersonID) REFERENCES Persons(PersonID);

97) To allow naming of a FOREIGN KEY constraint, and for defining a FOREIGN KEY constraint on multiple columns, use the following SQL syntax:
ALTER TABLE Orders
ADD CONSTRAINT FK_PersonOrder
FOREIGN KEY (PersonID) REFERENCES Persons(PersonID);

98) To drop a FOREIGN KEY constraint, use the following SQL:
ALTER TABLE Orders
DROP FOREIGN KEY FK_PersonOrder;

99) The CHECK constraint is used to limit the value range that can be placed in a column. If you define a CHECK constraint on a single column it allows only certain values for this column. If you define a CHECK constraint on a table it can limit the values in certain columns based on values in other columns in the row.

100) The following SQL creates a CHECK constraint on the "Age" column when the "Persons" table is created. The CHECK constraint ensures that you can not have any person below 18 years:
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    CHECK (Age>=18)
);

101) To allow naming of a CHECK constraint, and for defining a CHECK constraint on multiple columns, use the following SQL syntax:
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    City varchar(255),
    CONSTRAINT CHK_Person CHECK (Age>=18 AND City='Sandnes')
);

102) To create a CHECK constraint on the "Age" column when the table is already created, use the following SQL:
ALTER TABLE Persons
ADD CHECK (Age>=18);

103) To allow naming of a CHECK constraint, and for defining a CHECK constraint on multiple columns, use the following SQL syntax:
ALTER TABLE Persons
ADD CONSTRAINT CHK_PersonAge CHECK (Age>=18 AND City='Sandnes');

104) To drop a CHECK constraint, use the following SQL:
ALTER TABLE Persons
DROP CHECK CHK_PersonAge;

104) The DEFAULT constraint is used to provide a default value for a column. The default value will be added to all new records IF no other value is specified.

105) The following SQL sets a DEFAULT value for the "City" column when the "Persons" table is created:
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    City varchar(255) DEFAULT 'Sandnes'
);

106) The DEFAULT constraint can also be used to insert system values, by using functions like GETDATE():
CREATE TABLE Orders (
    ID int NOT NULL,
    OrderNumber int NOT NULL,
    OrderDate date DEFAULT GETDATE()
);

107) To create a DEFAULT constraint on the "City" column when the table is already created, use the following SQL:
ALTER TABLE Persons
ALTER City SET DEFAULT 'Sandnes';

108) To drop a DEFAULT constraint, use the following SQL:
ALTER TABLE Persons
ALTER City DROP DEFAULT;

109) The CREATE INDEX statement is used to create indexes in tables. Indexes are used to retrieve data from the database very fast. The users cannot see the indexes, they are just used to speed up searches/queries.

110) Updating a table with indexes takes more time than updating a table without (because the indexes also need an update). So, only create indexes on columns that will be frequently searched against.

111) The SQL statement below creates an index named "idx_lastname" on the "LastName" column in the "Persons" table:
CREATE INDEX idx_lastname
ON Persons (LastName);

112) If you want to create an index on a combination of columns, you can list the column names within the parentheses, separated by commas:
CREATE INDEX idx_pname
ON Persons (LastName, FirstName);

113) The DROP INDEX statement is used to delete an index in a table.
ALTER TABLE table_name
DROP INDEX index_name;

114) Auto-increment allows a unique number to be generated automatically when a new record is inserted into a table. Often this is the primary key field that we would like to be created automatically every time a new record is inserted.

115) The following SQL statement defines the "ID" column to be an auto-increment primary key field in the "Persons" table:  MySQL uses the AUTO_INCREMENT keyword to perform an auto-increment feature.
CREATE TABLE Persons (
    ID int NOT NULL AUTO_INCREMENT,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    PRIMARY KEY (ID)
);

116) By default, the starting value for AUTO_INCREMENT is 1, and it will increment by 1 for each new record. To let the AUTO_INCREMENT sequence start with another value, use the following SQL statement:
ALTER TABLE Persons AUTO_INCREMENT=100;

117) To insert a new record into the "Persons" table, we will NOT have to specify a value for the "ID" column (a unique value will be added automatically):
INSERT INTO Persons (FirstName,LastName)
VALUES ('Lars','Monsen');

118) The most difficult part when working with dates is to be sure that the format of the date you are trying to insert, matches the format of the date column in the database. As long as your data contains only the date portion, your queries will work as expected. However, if a time portion is involved, it gets more complicated.

119) SQL Date Data Types, MySQL comes with the following data types for storing a date or a date/time value in the database:
DATE - format YYYY-MM-DD
DATETIME - format: YYYY-MM-DD HH:MI:SS
TIMESTAMP - format: YYYY-MM-DD HH:MI:SS
YEAR - format YYYY or YY

120) You can compare two dates easily if there is no time component involved! To keep your queries simple and easy to maintain, do not allow time components in your dates!
SELECT * FROM Orders WHERE OrderDate='2008-11-11'

121) In SQL, a view is a virtual table based on the result-set of an SQL statement. A view contains rows and columns, just like a real table. The fields in a view are fields from one or more real tables in the database. You can add SQL functions, WHERE, and JOIN statements to a view and present the data as if the data were coming from one single table.

122) A view always shows up-to-date data! The database engine recreates the data, using the view's SQL statement, every time a user queries a view.

123) The view "Current Product List" lists all active products (products that are not discontinued) from the "Products" table. The view is created with the following SQL:
CREATE VIEW [Current Product List] AS
SELECT ProductID, ProductName
FROM Products
WHERE Discontinued = No;
SELECT * FROM [Current Product List];

CREATE VIEW [Products Above Average Price] AS
SELECT ProductName, UnitPrice
FROM Products
WHERE UnitPrice > (SELECT AVG(UnitPrice) FROM Products);
SELECT * FROM [Products Above Average Price];

124) Now we want to add the "Category" column to the "Current Product List" view. We will update the view with the following SQL:
CREATE OR REPLACE VIEW [Current Product List] AS
SELECT ProductID, ProductName, Category
FROM Products
WHERE Discontinued = No;

125) DROP VIEW view_name;


126) SQL injection is a code injection technique that might destroy your database. SQL injection is one of the most common web hacking techniques. SQL injection is the placement of malicious code in SQL statements, via web page input.

127) MySQL has many built-in functions. This reference contains the string, numeric, date, and advanced functions in MySQL.

128) MySQL String Functions
Function			Description
ASCII				Returns the number code that represents the specific character
CHAR_LENGTH			Returns the length of the specified string (in characters)
CHARACTER_LENGTH	Returns the length of the specified string (in characters)
CONCAT				Concatenates two or more expressions together
CONCAT_WS			Concatenates two or more expressions together and adds a separator between them
FIELD				Returns the position of a value in a list of values
FIND_IN_SET			Returns the position of a string in a string list
FORMAT				Formats a number as a format of "#,###.##", rounding it to a certain number of decimal places
INSERT				Inserts a substring into a string at a specified position for a certain number of characters
INSTR				Returns the position of the first occurrence of a string in another string
LCASE				Converts a string to lower-case
LEFT				Extracts a substring from a string (starting from left)
LENGTH				Returns the length of the specified string (in bytes)
LOCATE				Returns the position of the first occurrence of a substring in a string
LOWER				Converts a string to lower-case
LPAD				Returns a string that is left-padded with a specified string to a certain length
LTRIM				Removes leading spaces from a string
MID					Extracts a substring from a string (starting at any position)
POSITION			Returns the position of the first occurrence of a substring in a string
REPEAT				Repeats a string a specified number of times
REPLACE				Replaces all occurrences of a specified string
REVERSE				Reverses a string and returns the result
RIGHT				Extracts a substring from a string (starting from right)
RPAD				Returns a string that is right-padded with a specified string to a certain length
RTRIM				Removes trailing spaces from a string
SPACE				Returns a string with a specified number of spaces
STRCMP				Tests whether two strings are the same
SUBSTR				Extracts a substring from a string (starting at any position)
SUBSTRING			Extracts a substring from a string (starting at any position)
SUBSTRING_INDEX		Returns the substring of string before number of occurrences of delimiter
TRIM				Removes leading and trailing spaces from a string
UCASE				Converts a string to upper-case
UPPER				Converts a string to upper-case

129) MySQL Numeric Functions
Function			Description
ABS					Returns the absolute value of a number
ACOS				Returns the arc cosine of a number
ASIN				Returns the arc sine of a number
ATAN				Returns the arc tangent of a number or the arc tangent of n and m
ATAN2				Returns the arc tangent of n and m
AVG					Returns the average value of an expression
CEIL				Returns the smallest integer value that is greater than or equal to a number
CEILING				Returns the smallest integer value that is greater than or equal to a number
COS					Returns the cosine of a number
COT					Returns the cotangent of a number
COUNT				Returns the number of records in a select query
DEGREES				Converts a radian value into degrees
DIV					Used for integer division
EXP					Returns e raised to the power of number
FLOOR				Returns the largest integer value that is less than or equal to a number
GREATEST			Returns the greatest value in a list of expressions
LEAST				Returns the smallest value in a list of expressions
LN					Returns the natural logarithm of a number
LOG					Returns the natural logarithm of a number or the logarithm of a number to a specified base
LOG10				Returns the base-10 logarithm of a number
LOG2				Returns the base-2 logarithm of a number
MAX					Returns the maximum value of an expression
MIN					Returns the minimum value of an expression
MOD					Returns the remainder of n divided by m
PI					Returns the value of PI displayed with 6 decimal places
POW					Returns m raised to the nth power
POWER				Returns m raised to the nth power
RADIANS				Converts a value in degrees to radians
RAND				Returns a random number or a random number within a range
ROUND				Returns a number rounded to a certain number of decimal places
SIGN				Returns a value indicating the sign of a number
SIN					Returns the sine of a number
SQRT				Returns the square root of a number
SUM					Returns the summed value of an expression
TAN					Returns the tangent of a number
TRUNCATE			Returns a number truncated to a certain number of decimal places

130)MySQL Date Functions
Function			Description
ADDDATE				Returns a date after a certain time/date interval has been added
ADDTIME				Returns a time/datetime after a certain time interval has been added
CURDATE				Returns the current date
CURRENT_DATE		Returns the current date
CURRENT_TIME		Returns the current time
CURRENT_TIMESTAMP	Returns the current date and time
CURTIME				Returns the current time
DATE				Extracts the date value from a date or datetime expression
DATEDIFF			Returns the difference in days between two date values
DATE_ADD			Returns a date after a certain time/date interval has been added
DATE_FORMAT			Formats a date as specified by a format mask
DATE_SUB			Returns a date after a certain time/date interval has been subtracted
DAY					Returns the day portion of a date value
DAYNAME				Returns the weekday name for a date
DAYOFMONTH			Returns the day portion of a date value
DAYOFWEEK			Returns the weekday index for a date value
DAYOFYEAR			Returns the day of the year for a date value
EXTRACT				Extracts parts from a date
FROM_DAYS			Returns a date value from a numeric representation of the day
HOUR				Returns the hour portion of a date value
LAST_DAY			Returns the last day of the month for a given date
LOCALTIME			Returns the current date and time
LOCALTIMESTAMP		Returns the current date and time
MAKEDATE			Returns the date for a certain year and day-of-year value
MAKETIME			Returns the time for a certain hour, minute, second combination
MICROSECOND			Returns the microsecond portion of a date value
MINUTE				Returns the minute portion of a date value
MONTH				Returns the month portion of a date value
MONTHNAME			Returns the full month name for a date
NOW					Returns the current date and time
PERIOD_ADD			Takes a period and adds a specified number of months to it
PERIOD_DIFF			Returns the difference in months between two periods
QUARTER				Returns the quarter portion of a date value
SECOND				Returns the second portion of a date value
SEC_TO_TIME			Converts numeric seconds into a time value
STR_TO_DATE			Takes a string and returns a date specified by a format mask
SUBDATE				Returns a date after which a certain time/date interval has been subtracted
SUBTIME				Returns a time/datetime value after a certain time interval has been subtracted
SYSDATE				Returns the current date and time
TIME				Extracts the time value from a time/datetime expression
TIME_FORMAT			Formats a time as specified by a format mask
TIME_TO_SEC			Converts a time value into numeric seconds
TIMEDIFF			Returns the difference between two time/datetime values
TIMESTAMP			Converts an expression to a datetime value and if specified adds an optional time interval to the value
TO_DAYS				Converts a date into numeric days
WEEK				Returns the week portion of a date value
WEEKDAY				Returns the weekday index for a date value
WEEKOFYEAR			Returns the week of the year for a date value
YEAR				Returns the year portion of a date value
YEARWEEK			Returns the year and week for a date value

131) MySQL Advanced Functions
Function		Description
BIN				Converts a decimal number to a binary number
BINARY			Converts a value to a binary string
CASE			Lets you evaluate conditions and return a value when the first condition is met
CAST			Converts a value from one datatype to another datatype
COALESCE		Returns the first non-null expression in a list
CONNECTION_ID	Returns the unique connection ID for the current connection
CONV			Converts a number from one number base to another
CONVERT			Converts a value from one datatype to another, or one character set to another
CURRENT_USER	Returns the user name and host name for the MySQL account used by the server to authenticate the current client
DATABASE		Returns the name of the default database
IF				Returns one value if a condition is TRUE, or another value if a condition is FALSE
IFNULL			Lets you to return an alternate value if an expression is NULL
ISNULL			Tests whether an expression is NULL
LAST_INSERT_ID	Returns the first AUTO_INCREMENT value that was set by the most recent INSERT or UPDATE statement
NULLIF			Compares two expressions
SESSION_USER	Returns the user name and host name for the current MySQL user
SYSTEM_USER		Returns the user name and host name for the current MySQL user
USER			Returns the user name and host name for the current MySQL user
VERSION			Returns the version of the MySQL database

132) Operator	Description	Example
+	Add	
-	Subtract
*	Multiply
/	Divide
%	Modulo
select 30 +20;
&	Bitwise AND
|	Bitwise OR
^	Bitwise exclusive OR
=	Equal to
>	Greater than
<	Less than
>=	Greater than or equal to
<=	Less than or equal to
<>	Not equal to

133) SQL Compound Operators
+=	Add equals
-=	Subtract equals
*=	Multiply equals
/=	Divide equals
%=	Modulo equals
&=	Bitwise AND equals
^-=	Bitwise exclusive equals
|*=	Bitwise OR equals

134) SQL Logical Operators
Operator	Description	Example
ALL			TRUE if all of the subquery values meet the condition
AND			TRUE if all the conditions separated by AND is TRUE
ANY			TRUE if any of the subquery values meet the condition
BETWEEN		TRUE if the operand is within the range of comparisons
EXISTS		TRUE if the subquery returns one or more records
IN			TRUE if the operand is equal to one of a list of expressions
LIKE		TRUE if the operand matches a pattern
NOT			Displays a record if the condition(s) is NOT TRUE
OR			TRUE if any of the conditions separated by OR is TRUE
SOME		TRUE if any of the subquery values meet the condition

135) A data type defines what kind of value a column can hold: integer data, character data, monetary data, date and time data, binary strings, and so on.

136) Each column in a database table is required to have a name and a data type. An SQL developer must decide what type of data that will be stored inside each column when creating a table. The data type is a guideline for SQL to understand what type of data is expected inside of each column, and it also identifies how SQL will interact with the stored data.
Note: Data types might have different names in different database. And even if the name is the same, the size and other details may be different! Always check the documentation!

137) In MySQL there are three main data types: text, number, and date.
Text data types:
Data type			Description
CHAR(size)			Holds a fixed length string (can contain letters, numbers, and special characters). The fixed size is specified in parenthesis. Can 					store up to 255 characters
VARCHAR(size)		Holds a variable length string (can contain letters, numbers, and special characters). The maximum size is specified in parenthesis. 					 Can store up to 255 characters. Note: If you put a greater value than 255 it will be converted to a TEXT type
TINYTEXT			Holds a string with a maximum length of 255 characters
TEXT				Holds a string with a maximum length of 65,535 characters
BLOB				For BLOBs (Binary Large OBjects). Holds up to 65,535 bytes of data
MEDIUMTEXT			Holds a string with a maximum length of 16,777,215 characters
MEDIUMBLOB			For BLOBs (Binary Large OBjects). Holds up to 16,777,215 bytes of data
LONGTEXT			Holds a string with a maximum length of 4,294,967,295 characters
LONGBLOB			For BLOBs (Binary Large OBjects). Holds up to 4,294,967,295 bytes of data
ENUM(x,y,z,etc.)	Let you enter a list of possible values. You can list up to 65535 values in an ENUM list. If a value is inserted that is not in the 					list, a blank value will be inserted.
					Note: The values are sorted in the order you enter them. 
					You enter the possible values in this format: ENUM('X','Y','Z')
SET					Similar to ENUM except that SET may contain up to 64 list items and can store more than one choice


137) Number data types:
Data type			Description
TINYINT(size)		-128 to 127 normal. 0 to 255 UNSIGNED*. The maximum number of digits may be specified in parenthesis
SMALLINT(size)		-32768 to 32767 normal. 0 to 65535 UNSIGNED*. The maximum number of digits may be specified in parenthesis
MEDIUMINT(size)		-8388608 to 8388607 normal. 0 to 16777215 UNSIGNED*. The maximum number of digits may be specified in parenthesis
INT(size)			-2147483648 to 2147483647 normal. 0 to 4294967295 UNSIGNED*. The maximum number of digits may be specified in parenthesis
BIGINT(size)		-9223372036854775808 to 9223372036854775807 normal. 0 to 18446744073709551615 UNSIGNED*. The maximum number of digits may be		
					specified in parenthesis
FLOAT(size,d)		A small number with a floating decimal point. The maximum number of digits may be specified in the size parameter. The maximum number 						of digits to the right of the decimal point is specified in the d parameter
DOUBLE(size,d)		A large number with a floating decimal point. The maximum number of digits may be specified in the size parameter. The maximum number 						of digits to the right of the decimal point is specified in the d parameter
DECIMAL(size,d)		A DOUBLE stored as a string , allowing for a fixed decimal point. The maximum number of digits may be specified in the size 	
					parameter. The maximum number of digits to the right of the decimal point is specified in the d parameter

*The integer types have an extra option called UNSIGNED. Normally, the integer goes from an negative to positive value. Adding the UNSIGNED attribute will move that range up so it starts at zero instead of a negative number.

138) Date data types:
Data type			Description
DATE()				A date. Format: YYYY-MM-DD
					Note: The supported range is from '1000-01-01' to '9999-12-31'
DATETIME()			*A date and time combination. Format: YYYY-MM-DD HH:MI:SS
					Note: The supported range is from '1000-01-01 00:00:00' to '9999-12-31 23:59:59'
TIMESTAMP()			*A timestamp. TIMESTAMP values are stored as the number of seconds since the Unix epoch ('1970-01-01 00:00:00' UTC). Format: 	
					YYYY-MM-DD HH:MI:SS
					Note: The supported range is from '1970-01-01 00:00:01' UTC to '2038-01-09 03:14:07' UTC
TIME()				A time. Format: HH:MI:SS
					Note: The supported range is from '-838:59:59' to '838:59:59'
YEAR()				A year in two-digit or four-digit format.
					Note: Values allowed in four-digit format: 1901 to 2155. Values allowed in two-digit format: 70 to 69, representing years from 1970 to 2069
*Even if DATETIME and TIMESTAMP return the same format, they work very differently. In an INSERT or UPDATE query, the TIMESTAMP automatically set itself to the current date and time. TIMESTAMP also accepts various formats, like YYYYMMDDHHMISS, YYMMDDHHMISS, YYYYMMDD, or YYMMDD.


#PostgreSQL新手入门
http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html
本文介绍PostgreSQL的安装和基本用法，供初次使用者上手。以下内容基于Debian操作系统
一、安装
1) 首先，安装PostgreSQL客户端。 sudo apt-get install postgresql-client
2) 然后，安装PostgreSQL服务器。
sudo apt-get install postgresql
3) 正常情况下，安装完成后，PostgreSQL服务器会自动在本机的5432端口开启。
4) 如果还想安装图形管理界面，可以运行下面命令，但是本文不涉及这方面内容。
sudo apt-get install pgadmin3
二、添加新用户和新数据库
1)初次安装后，默认生成一个名为postgres的数据库和一个名为postgres的数据库用户。这里需要注意的是，同时还生成了一个名为postgres的Linux系统用户。
2)下面，我们使用postgres用户，来生成其他用户和新数据库。好几种方法可以达到这个目的，这里介绍两种。
3) 第一种方法，使用PostgreSQL控制台。
3.1) 首先，新建一个Linux新用户，可以取你想要的名字，这里为dbuser。
sudo adduser dbuser
3.2) 然后，切换到postgres用户。 sudo su - postgres
下一步，使用psql命令登录PostgreSQL控制台。 psql
3.3) 这时相当于系统用户postgres以同名数据库用户的身份，登录数据库，这是不用输入密码的。如果一切正常，系统提示符会变为"postgres=#"，表示这时已经进入了数据库控制台。以下的命令都在控制台内完成。
3.5) 第一件事是使用\password命令，为postgres用户设置一个密码。
\password postgres
3.6) 第二件事是创建数据库用户dbuser（刚才创建的是Linux系统用户），并设置密码。
CREATE USER dbuser WITH PASSWORD 'password';
3.7) 第三件事是创建用户数据库，这里为exampledb，并指定所有者为dbuser。
CREATE DATABASE exampledb OWNER dbuser;
3.8) 第四件事是将exampledb数据库的所有权限都赋予dbuser，否则dbuser只能登录控制台，没有任何数据库操作权限。
GRANT ALL PRIVILEGES ON DATABASE exampledb to dbuser;
3.9) 最后，使用\q命令退出控制台（也可以直接按ctrl+D）。
\q
4) 第二种方法，使用shell命令行。
4.1) 添加新用户和新数据库，除了在PostgreSQL控制台内，还可以在shell命令行下完成。这是因为PostgreSQL提供了命令行程序createuser和createdb。还是以新建用户dbuser和数据库exampledb为例。
4.2) 首先，创建数据库用户dbuser，并指定其为超级用户。
sudo -u postgres createuser --superuser dbuser
4.3) 然后，登录数据库控制台，设置dbuser用户的密码，完成后退出控制台。
4.4) sudo -u postgres psql
\password dbuser
\q
4.5) 接着，在shell命令行下，创建数据库exampledb，并指定所有者为dbuser。
sudo -u postgres createdb -O dbuser exampledb
三、登录数据库
1) 添加新用户和新数据库以后，就要以新用户的名义登录数据库，这时使用的是psql命令。
psql -U dbuser -d exampledb -h 127.0.0.1 -p 5432
上面命令的参数含义如下：-U指定用户，-d指定数据库，-h指定服务器，-p指定端口。
2) 输入上面命令以后，系统会提示输入dbuser用户的密码。输入正确，就可以登录控制台了。
3) psql命令存在简写形式。如果当前Linux系统用户，同时也是PostgreSQL用户，则可以省略用户名（-U参数的部分）。举例来说，我的Linux系统用户名为ruanyf，且PostgreSQL数据库存在同名用户，则我以ruanyf身份登录Linux系统后，可以直接使用下面的命令登录数据库，且不需要密码。
psql exampledb
4) 此时，如果PostgreSQL内部还存在与当前系统用户同名的数据库，则连数据库名都可以省略。比如，假定存在一个叫做ruanyf的数据库，则直接键入psql就可以登录该数据库。
psql
5) 另外，如果要恢复外部数据，可以使用下面的命令。
psql exampledb < exampledb.sql

四、控制台命令
1) 除了前面已经用到的\password命令（设置密码）和\q命令（退出）以外，控制台还提供一系列其他命令。
\h：查看SQL命令的解释，比如\h select。
\?：查看psql命令列表。
\l：列出所有数据库。
\c [database_name]：连接其他数据库。
\d：列出当前数据库的所有表格。
\d [table_name]：列出某一张表格的结构。
\du：列出所有用户。
\e：打开文本编辑器。
\conninfo：列出当前数据库和连接的信息。

五、数据库操作
1)基本的数据库操作，就是使用一般的SQL语言。
# 创建新表 
CREATE TABLE user_tbl(name VARCHAR(20), signup_date DATE);
# 插入数据 
INSERT INTO user_tbl(name, signup_date) VALUES('张三', '2013-12-22');
# 选择记录 
SELECT * FROM user_tbl;
# 更新数据 
UPDATE user_tbl set name = '李四' WHERE name = '张三';
# 删除记录 
DELETE FROM user_tbl WHERE name = '李四' ;
# 添加栏位 
ALTER TABLE user_tbl ADD email VARCHAR(40);
# 更新结构 
ALTER TABLE user_tbl ALTER COLUMN signup_date SET NOT NULL;
# 更名栏位 
ALTER TABLE user_tbl RENAME COLUMN signup_date TO signup;
# 删除栏位 
ALTER TABLE user_tbl DROP COLUMN email;
# 表格更名 
ALTER TABLE user_tbl RENAME TO backup_tbl;
# 删除表格 
DROP TABLE IF EXISTS backup_tbl;

#presgresql
1) Aggregate functions compute a single result from a set of input values. 
string_agg(expression, delimiter) argument types: (text, text) or (bytea, bytea) input values concatenated into a string, separated by delimiter
0.2,0.4,0.8
2) COALESCE (Return the first non-null expression in a list) SELECT COALESCE(NULL, NULL, NULL, 'W3Schools.com', NULL, 'Example.com'); // W3Schools.com
COALESCE (CAST(pf.weight_value as varchar),''), if pf.weight_value!=null, return pf.weight_value as string, otherwise return ''
3) 
3) CAST(pf.weight_value as varchar) : cast double into varchar (0.4 -> '0.4')

